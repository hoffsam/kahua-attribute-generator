{"version":3,"file":"conditionals.test.js","sourceRoot":"","sources":["../../../src/test/suite/conditionals.test.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\r\nimport * as vscode from 'vscode';\r\n\r\n// Import the functions we want to test\r\n// We'll need to export these from extension.ts for testing\r\n// For now, we'll re-implement the core logic or import it\r\n\r\nsuite('Enhanced Conditional Expression Tests', () => {\r\n\t\r\n\t// Helper function to evaluate expressions (copied from extension.ts for testing)\r\n\tfunction evaluateExpression(expression: string): boolean {\r\n\t\texpression = expression.trim();\r\n\t\t\r\n\t\t// Handle ternary operator\r\n\t\tconst ternaryResult = findTernaryOperator(expression);\r\n\t\tif (ternaryResult) {\r\n\t\t\tconst { condition, trueValue, falseValue } = ternaryResult;\r\n\t\t\tconst conditionResult = evaluateExpression(condition);\r\n\t\t\treturn conditionResult;\r\n\t\t}\r\n\t\t\r\n\t\t// Handle logical OR\r\n\t\tconst orResult = findLogicalOperator(expression, '||');\r\n\t\tif (orResult) {\r\n\t\t\tconst { left, right } = orResult;\r\n\t\t\treturn evaluateExpression(left) || evaluateExpression(right);\r\n\t\t}\r\n\t\t\r\n\t\t// Handle logical AND\r\n\t\tconst andResult = findLogicalOperator(expression, '&&');\r\n\t\tif (andResult) {\r\n\t\t\tconst { left, right } = andResult;\r\n\t\t\treturn evaluateExpression(left) && evaluateExpression(right);\r\n\t\t}\r\n\t\t\r\n\t\t// Handle parentheses\r\n\t\tif (expression.startsWith('(') && expression.endsWith(')')) {\r\n\t\t\tconst inner = expression.slice(1, -1).trim();\r\n\t\t\tif (isBalancedParentheses(inner)) {\r\n\t\t\t\treturn evaluateExpression(inner);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Handle 'not in' operator\r\n\t\tconst notInMatch = expression.match(/^\"([^\"]*?)\"\\s+not\\s+in\\s+\\(([^)]+)\\)$/i);\r\n\t\tif (notInMatch) {\r\n\t\t\tconst [, value, listStr] = notInMatch;\r\n\t\t\tconst list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\r\n\t\t\treturn !list.includes(value);\r\n\t\t}\r\n\t\t\r\n\t\t// Handle 'in' operator\r\n\t\tconst inMatch = expression.match(/^\"([^\"]*?)\"\\s+in\\s+\\(([^)]+)\\)$/i);\r\n\t\tif (inMatch) {\r\n\t\t\tconst [, value, listStr] = inMatch;\r\n\t\t\tconst list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\r\n\t\t\treturn list.includes(value);\r\n\t\t}\r\n\t\t\r\n\t\t// Handle comparison operators\r\n\t\tconst comparisonMatch = expression.match(/^\"([^\"]*?)\"\\s*(==|!=|<=|>=|<>)\\s*\"([^\"]*?)\"$/);\r\n\t\tif (comparisonMatch) {\r\n\t\t\tconst [, left, operator, right] = comparisonMatch;\r\n\t\t\t\r\n\t\t\tswitch (operator) {\r\n\t\t\t\tcase '==':\r\n\t\t\t\t\treturn left === right;\r\n\t\t\t\tcase '!=':\r\n\t\t\t\tcase '<>':\r\n\t\t\t\t\treturn left !== right;\r\n\t\t\t\tcase '<=':\r\n\t\t\t\t\treturn left <= right;\r\n\t\t\t\tcase '>=':\r\n\t\t\t\t\treturn left >= right;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Handle simple boolean expressions\r\n\t\tif (expression === '\"\"' || expression === 'false' || expression === '0') {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Helper functions (copied from extension.ts for testing)\r\n\tfunction isBalancedParentheses(expression: string): boolean {\r\n\t\tlet count = 0;\r\n\t\tfor (const char of expression) {\r\n\t\t\tif (char === '(') count++;\r\n\t\t\telse if (char === ')') count--;\r\n\t\t\tif (count < 0) return false;\r\n\t\t}\r\n\t\treturn count === 0;\r\n\t}\r\n\r\n\tfunction findTernaryOperator(expression: string): { condition: string; trueValue: string; falseValue: string } | null {\r\n\t\tlet parenCount = 0;\r\n\t\tlet questionPos = -1;\r\n\t\tlet colonPos = -1;\r\n\t\t\r\n\t\tfor (let i = 0; i < expression.length; i++) {\r\n\t\t\tconst char = expression[i];\r\n\t\t\tif (char === '(') parenCount++;\r\n\t\t\telse if (char === ')') parenCount--;\r\n\t\t\telse if (char === '?' && parenCount === 0 && questionPos === -1) {\r\n\t\t\t\tquestionPos = i;\r\n\t\t\t} else if (char === ':' && parenCount === 0 && questionPos !== -1 && colonPos === -1) {\r\n\t\t\t\tcolonPos = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (questionPos !== -1 && colonPos !== -1) {\r\n\t\t\tconst condition = expression.substring(0, questionPos).trim();\r\n\t\t\tconst trueValue = expression.substring(questionPos + 1, colonPos).trim();\r\n\t\t\tconst falseValue = expression.substring(colonPos + 1).trim();\r\n\t\t\treturn { condition, trueValue, falseValue };\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\r\n\tfunction findLogicalOperator(expression: string, operator: '&&' | '||'): { left: string; right: string } | null {\r\n\t\tlet parenCount = 0;\r\n\t\tconst opLength = operator.length;\r\n\t\t\r\n\t\tfor (let i = expression.length - opLength; i >= 0; i--) {\r\n\t\t\tconst char = expression[i];\r\n\t\t\t\r\n\t\t\tif (char === ')') parenCount++;\r\n\t\t\telse if (char === '(') parenCount--;\r\n\t\t\telse if (parenCount === 0 && expression.substr(i, opLength) === operator) {\r\n\t\t\t\tconst left = expression.substring(0, i).trim();\r\n\t\t\t\tconst right = expression.substring(i + opLength).trim();\r\n\t\t\t\tif (left && right) {\r\n\t\t\t\t\treturn { left, right };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Helper function to evaluate conditional with token substitution\r\n\tfunction evaluateConditionalWithTokens(expression: string, tokenValues: Record<string, string>): boolean {\r\n\t\t// Replace tokens in the expression with their values\r\n\t\tlet processedExpression = expression;\r\n\t\t\r\n\t\tconst tokenPattern = /\\{\\$(\\w+)\\}/g;\r\n\t\tlet match;\r\n\t\twhile ((match = tokenPattern.exec(expression)) !== null) {\r\n\t\t\tconst tokenName = match[1];\r\n\t\t\tconst tokenValue = tokenValues[tokenName] || '';\r\n\t\t\tprocessedExpression = processedExpression.replace(match[0], `\"${tokenValue.replace(/\"/g, '\\\\\\\\\"')}\"`);\r\n\t\t}\r\n\t\t\r\n\t\treturn evaluateExpression(processedExpression);\r\n\t}\r\n\r\n\tsuite('Basic Logical Operators', () => {\r\n\t\ttest('AND operator - both true', () => {\r\n\t\t\tconst tokens = { type: 'Text', required: 'true' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Text\" && {$required}==\"true\"', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\r\n\t\ttest('AND operator - one false', () => {\r\n\t\t\tconst tokens = { type: 'Text', required: 'false' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Text\" && {$required}==\"true\"', tokens);\r\n\t\t\tassert.strictEqual(result, false);\r\n\t\t});\r\n\r\n\t\ttest('OR operator - one true', () => {\r\n\t\t\tconst tokens = { type: 'Lookup', other: 'false' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Lookup\" || {$type}==\"Entity\"', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\r\n\t\ttest('OR operator - both false', () => {\r\n\t\t\tconst tokens = { type: 'Text', other: 'false' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Lookup\" || {$type}==\"Entity\"', tokens);\r\n\t\t\tassert.strictEqual(result, false);\r\n\t\t});\r\n\r\n\t\ttest('Mixed AND/OR with parentheses', () => {\r\n\t\t\tconst tokens = { type: 'Text', required: 'true', category: 'Standard' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Text\" && ({$required}==\"true\" || {$category}==\"Critical\")', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\t});\r\n\r\n\tsuite('Parentheses Grouping', () => {\r\n\t\ttest('Simple parentheses grouping', () => {\r\n\t\t\tconst tokens = { type: 'Integer', required: 'true' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('({$type}==\"Text\" || {$type}==\"Integer\") && {$required}==\"true\"', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\r\n\t\ttest('Nested parentheses', () => {\r\n\t\t\tconst tokens = { category: 'Advanced', type: 'Entity', linkedEntityDef: 'SomeEntity' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$category}==\"Advanced\" && ({$type}==\"Lookup\" || ({$type}==\"Entity\" && {$linkedEntityDef}!=\"\"))', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\t});\r\n\r\n\tsuite('Nested Ternary Operations', () => {\r\n\t\ttest('Simple nested ternary', () => {\r\n\t\t\tconst tokens = { type: 'Lookup', required: 'true' };\r\n\t\t\t\r\n\t\t\t// Test the ternary parsing\r\n\t\t\tconst ternaryResult = findTernaryOperator('{$type}==\"Lookup\" ? ({$required}==\"true\" ? \"RequiredLookup\" : \"OptionalLookup\") : \"NotLookup\"');\r\n\t\t\tassert.ok(ternaryResult);\r\n\t\t\tassert.strictEqual(ternaryResult.condition, '{$type}==\"Lookup\"');\r\n\t\t\tassert.strictEqual(ternaryResult.trueValue, '({$required}==\"true\" ? \"RequiredLookup\" : \"OptionalLookup\")');\r\n\t\t\tassert.strictEqual(ternaryResult.falseValue, '\"NotLookup\"');\r\n\t\t});\r\n\r\n\t\ttest('Complex nested ternary', () => {\r\n\t\t\tconst expression = '{$category}==\"Advanced\" ? ({$type}==\"Lookup\" ? \"AdvancedLookup\" : ({$type}==\"Entity\" ? \"AdvancedEntity\" : \"AdvancedOther\")) : \"Standard\"';\r\n\t\t\tconst ternaryResult = findTernaryOperator(expression);\r\n\t\t\tassert.ok(ternaryResult);\r\n\t\t\tassert.strictEqual(ternaryResult.condition, '{$category}==\"Advanced\"');\r\n\t\t});\r\n\t});\r\n\r\n\tsuite('Curly Braces in Literals', () => {\r\n\t\ttest('JSON literals with curly braces', () => {\r\n\t\t\t// Test that curly braces in string literals don't interfere with token parsing\r\n\t\t\tconst template = '{$type}==\"Config\" ? \\'{\"setting\": \"{$name}\", \"value\": \"{$label}\"}\\' : \"simple\"';\r\n\t\t\tconst ternaryResult = findTernaryOperator(template);\r\n\t\t\tassert.ok(ternaryResult);\r\n\t\t\tassert.strictEqual(ternaryResult.condition, '{$type}==\"Config\"');\r\n\t\t\tassert.strictEqual(ternaryResult.trueValue, '\\'{\"setting\": \"{$name}\", \"value\": \"{$label}\"}\\'');\r\n\t\t\tassert.strictEqual(ternaryResult.falseValue, '\"simple\"');\r\n\t\t});\r\n\r\n\t\ttest('CSS literals with curly braces', () => {\r\n\t\t\tconst template = '{$visualtype}==\"Custom\" ? \\'.{$name} { display: block; }\\' : \"default\"';\r\n\t\t\tconst ternaryResult = findTernaryOperator(template);\r\n\t\t\tassert.ok(ternaryResult);\r\n\t\t\tassert.strictEqual(ternaryResult.condition, '{$visualtype}==\"Custom\"');\r\n\t\t\tassert.strictEqual(ternaryResult.trueValue, '\\'.{$name} { display: block; }\\'');\r\n\t\t});\r\n\r\n\t\ttest('JavaScript literals with curly braces', () => {\r\n\t\t\tconst template = '{$type}==\"Function\" ? \\'function {$name}() { return \"{$label}\"; }\\' : \\'var {$name} = \"{$label}\";\\'';\r\n\t\t\tconst ternaryResult = findTernaryOperator(template);\r\n\t\t\tassert.ok(ternaryResult);\r\n\t\t\tassert.strictEqual(ternaryResult.condition, '{$type}==\"Function\"');\r\n\t\t});\r\n\t});\r\n\r\n\tsuite('Operator Precedence', () => {\r\n\t\ttest('AND has higher precedence than OR', () => {\r\n\t\t\t// \"A\" || \"B\" && \"C\" should be parsed as \"A\" || (\"B\" && \"C\")\r\n\t\t\tconst expression = '\"false\" || \"true\" && \"true\"';\r\n\t\t\tconst orResult = findLogicalOperator(expression, '||');\r\n\t\t\tassert.ok(orResult);\r\n\t\t\tassert.strictEqual(orResult.left, '\"false\"');\r\n\t\t\tassert.strictEqual(orResult.right, '\"true\" && \"true\"');\r\n\t\t});\r\n\r\n\t\ttest('Parentheses override precedence', () => {\r\n\t\t\t// (\"A\" || \"B\") && \"C\" should be parsed correctly\r\n\t\t\tconst expression = '(\"false\" || \"true\") && \"true\"';\r\n\t\t\tconst andResult = findLogicalOperator(expression, '&&');\r\n\t\t\tassert.ok(andResult);\r\n\t\t\tassert.strictEqual(andResult.left, '(\"false\" || \"true\")');\r\n\t\t\tassert.strictEqual(andResult.right, '\"true\"');\r\n\t\t});\r\n\t});\r\n\r\n\tsuite('Edge Cases', () => {\r\n\t\ttest('Empty token values', () => {\r\n\t\t\tconst tokens = { type: '', required: 'true' };\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"\" && {$required}==\"true\"', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\r\n\t\ttest('Missing tokens default to empty string', () => {\r\n\t\t\tconst tokens = { type: 'Text' }; // missing 'required' token\r\n\t\t\tconst result = evaluateConditionalWithTokens('{$type}==\"Text\" && {$required}==\"\"', tokens);\r\n\t\t\tassert.strictEqual(result, true);\r\n\t\t});\r\n\r\n\t\ttest('Unbalanced parentheses', () => {\r\n\t\t\tconst expression = '((\"Text\" || \"Integer\") && \"true\"';\r\n\t\t\tassert.strictEqual(isBalancedParentheses(expression), false);\r\n\t\t});\r\n\r\n\t\ttest('Balanced parentheses', () => {\r\n\t\t\tconst expression = '((\"Text\" || \"Integer\") && \"true\")';\r\n\t\t\tassert.strictEqual(isBalancedParentheses(expression), true);\r\n\t\t});\r\n\t});\r\n});\r\n\r\nsuite('Token Transformation Tests', () => {\r\n\t// Helper functions (similar to extension logic)\r\n\tfunction escapeXml(value: string): string {\r\n\t\tif (!value) return value;\r\n\t\treturn value\r\n\t\t\t.replace(/&/g, '&amp;')\r\n\t\t\t.replace(/</g, '&lt;')\r\n\t\t\t.replace(/>/g, '&gt;')\r\n\t\t\t.replace(/\"/g, '&quot;')\r\n\t\t\t.replace(/'/g, '&#39;');\r\n\t}\r\n\r\n\tfunction toPascalCase(value: string): string {\r\n\t\tif (!value) return value;\r\n\t\treturn value\r\n\t\t\t.split(/[^a-zA-Z0-9]+/)\r\n\t\t\t.filter(word => word.length > 0)\r\n\t\t\t.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\r\n\t\t\t.join('');\r\n\t}\r\n\r\n\tfunction toTitleCase(value: string): string {\r\n\t\tif (!value) return value;\r\n\t\t\r\n\t\tconst lowercaseWords = new Set([\r\n\t\t\t'a', 'an', 'the', 'and', 'or', 'but', 'nor', 'yet', 'so',\r\n\t\t\t'in', 'on', 'at', 'by', 'for', 'of', 'to', 'up', 'as'\r\n\t\t]);\r\n\t\t\r\n\t\tconst words = value.toLowerCase().split(/(\\s+)/);\r\n\t\t\r\n\t\treturn words.map((word, index) => {\r\n\t\t\tif (/^\\s+$/.test(word)) {\r\n\t\t\t\treturn word;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst isFirstWord = index === 0 || words.slice(0, index).every(w => /^\\s+$/.test(w));\r\n\t\t\tconst isLastWord = index === words.length - 1 || words.slice(index + 1).every(w => /^\\s+$/.test(w));\r\n\t\t\t\r\n\t\t\tif (isFirstWord || isLastWord || !lowercaseWords.has(word.toLowerCase())) {\r\n\t\t\t\treturn word.charAt(0).toUpperCase() + word.slice(1);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn word;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\tfunction applyTokenTransformation(value: string, transformation: string): string {\r\n\t\tif (!value) return value;\r\n\t\t\r\n\t\tswitch (transformation.toLowerCase()) {\r\n\t\t\tcase 'friendly':\r\n\t\t\t\treturn escapeXml(toTitleCase(value));\r\n\t\t\tcase 'internal':\r\n\t\t\t\treturn toPascalCase(value);\r\n\t\t\tcase 'upper':\r\n\t\t\t\treturn escapeXml(value.toUpperCase());\r\n\t\t\tcase 'lower':\r\n\t\t\t\treturn escapeXml(value.toLowerCase());\r\n\t\t\tdefault:\r\n\t\t\t\treturn toPascalCase(value);\r\n\t\t}\r\n\t}\r\n\r\n\ttest('Default transformation creates PascalCase', () => {\r\n\t\tconst result = applyTokenTransformation('field & value', 'default');\r\n\t\tassert.strictEqual(result, 'FieldValue');\r\n\t});\r\n\r\n\ttest('Friendly transformation applies TitleCase', () => {\r\n\t\tconst result = applyTokenTransformation('field of the rings', 'friendly');\r\n\t\tassert.strictEqual(result, 'Field of the Rings');\r\n\t});\r\n\r\n\ttest('Internal transformation creates PascalCase', () => {\r\n\t\tconst result = applyTokenTransformation('field & value', 'internal');\r\n\t\tassert.strictEqual(result, 'FieldValue');\r\n\t});\r\n\r\n\ttest('Upper transformation converts to uppercase with XML escaping', () => {\r\n\t\tconst result = applyTokenTransformation('field & value', 'upper');\r\n\t\tassert.strictEqual(result, 'FIELD &amp; VALUE');\r\n\t});\r\n\r\n\ttest('Lower transformation converts to lowercase with XML escaping', () => {\r\n\t\tconst result = applyTokenTransformation('FIELD & VALUE', 'lower');\r\n\t\tassert.strictEqual(result, 'field &amp; value');\r\n\t});\r\n\r\n\ttest('PascalCase handles complex input', () => {\r\n\t\tconst result = applyTokenTransformation('user-defined field name', 'default');\r\n\t\tassert.strictEqual(result, 'UserDefinedFieldName');\r\n\t});\r\n\r\n\ttest('TitleCase handles articles and prepositions correctly', () => {\r\n\t\tconst result = applyTokenTransformation('the field of dreams and hope', 'friendly');\r\n\t\tassert.strictEqual(result, 'The Field of Dreams and Hope');\r\n\t});\r\n\r\n\ttest('TitleCase capitalizes first and last words', () => {\r\n\t\tconst result = applyTokenTransformation('a field for the user', 'friendly');\r\n\t\tassert.strictEqual(result, 'A Field for the User');\r\n\t});\r\n\r\n\ttest('XML escaping handles all special characters', () => {\r\n\t\tconst input = '<tag attr=\"value\">content & more\\'s</tag>';\r\n\t\tconst expected = '&lt;tag attr=&quot;value&quot;&gt;content &amp; more&#39;s&lt;/tag&gt;';\r\n\t\tconst result = applyTokenTransformation(input, 'friendly');\r\n\t\tassert.strictEqual(result, expected);\r\n\t});\r\n\r\n\ttest('Token pattern matching with pipe syntax', () => {\r\n\t\tconst template = '<Label>{$name|upper}</Label><Field>{$value|friendly}</Field>';\r\n\t\t\r\n\t\t// Test that the regex pattern correctly identifies pipe transformations\r\n\t\tconst tokenPattern = /\\{\\$(\\w+)(?:\\|([^}]+))?\\}/g;\r\n\t\tconst matches = [];\r\n\t\tlet match;\r\n\t\t\r\n\t\twhile ((match = tokenPattern.exec(template)) !== null) {\r\n\t\t\tmatches.push({\r\n\t\t\t\ttoken: match[1],\r\n\t\t\t\ttransformation: match[2] || 'default'\r\n\t\t\t});\r\n\t\t}\r\n\t\t\r\n\t\tassert.strictEqual(matches.length, 2);\r\n\t\tassert.strictEqual(matches[0].token, 'name');\r\n\t\tassert.strictEqual(matches[0].transformation, 'upper');\r\n\t\tassert.strictEqual(matches[1].token, 'value');\r\n\t\tassert.strictEqual(matches[1].transformation, 'friendly');\r\n\t});\r\n});\r\n\r\nsuite('Template Processing Integration Tests', () => {\r\n\ttest('Full template processing with enhanced conditionals', () => {\r\n\t\t// This would test the full pipeline from template to output\r\n\t\t// For now, just verify the structure exists\r\n\t\tassert.ok(true, 'Integration tests placeholder');\r\n\t});\r\n});"]}