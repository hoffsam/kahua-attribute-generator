{"version":3,"file":"extension.js","sourceRoot":"","sources":["../src/extension.ts"],"names":[],"mappings":"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","sourcesContent":["import * as vscode from 'vscode';\n\n/**\n * Represents a conditional expression result\n */\ninterface ConditionalResult {\n  condition: boolean;\n  hasValidTokens: boolean;\n  invalidTokens: string[];\n}\n\n/**\n * Cleans a token value by removing internal whitespace and special characters\n * for use in XML attributes and identifiers\n */\nfunction cleanTokenValue(value: string): string {\n  if (!value) return value;\n  \n  // Remove internal whitespace and common special characters\n  // Keep alphanumeric characters, hyphens, and underscores\n  return value.replace(/\\s+/g, '').replace(/[^a-zA-Z0-9\\-_]/g, '');\n}\n\n/**\n * Evaluates a conditional expression with token values\n */\nfunction evaluateConditional(expression: string, tokenValues: Record<string, string>): ConditionalResult {\n  const invalidTokens: string[] = [];\n  let hasValidTokens = true;\n  \n  // Replace tokens in the expression with their values\n  let processedExpression = expression;\n  \n  // Find all token references in the expression\n  const tokenPattern = /\\{\\$(\\w+)\\}/g;\n  let match;\n  while ((match = tokenPattern.exec(expression)) !== null) {\n    const tokenName = match[1];\n    const tokenValue = tokenValues[tokenName];\n    \n    if (tokenValue === undefined || tokenValue === '') {\n      invalidTokens.push(tokenName);\n      hasValidTokens = false;\n      // Replace with empty string for evaluation\n      processedExpression = processedExpression.replace(match[0], '\"\"');\n    } else {\n      // Replace with quoted string value for evaluation\n      processedExpression = processedExpression.replace(match[0], `\"${tokenValue.replace(/\"/g, '\\\\\"')}\"`);\n    }\n  }\n  \n  try {\n    // Parse and evaluate the conditional expression\n    const result = evaluateExpression(processedExpression);\n    return {\n      condition: result,\n      hasValidTokens,\n      invalidTokens\n    };\n  } catch (error) {\n    return {\n      condition: false,\n      hasValidTokens: false,\n      invalidTokens\n    };\n  }\n}\n\n/**\n * Safely evaluates a conditional expression\n * Supports: ==, !=, <=, >=, <>, in, not in, ternary operator\n */\nfunction evaluateExpression(expression: string): boolean {\n  // Remove extra whitespace\n  expression = expression.trim();\n  \n  // Handle ternary operator (condition ? value : fallback)\n  const ternaryMatch = expression.match(/^(.+?)\\s*\\?\\s*(.+?)\\s*:\\s*(.+)$/);\n  if (ternaryMatch) {\n    const [, condition, trueValue, falseValue] = ternaryMatch;\n    const conditionResult = evaluateExpression(condition);\n    return conditionResult;\n  }\n  \n  // Handle 'not in' operator\n  const notInMatch = expression.match(/^\"([^\"]*?)\"\\s+not\\s+in\\s+\\(([^)]+)\\)$/i);\n  if (notInMatch) {\n    const [, value, listStr] = notInMatch;\n    const list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\n    return !list.includes(value);\n  }\n  \n  // Handle 'in' operator\n  const inMatch = expression.match(/^\"([^\"]*?)\"\\s+in\\s+\\(([^)]+)\\)$/i);\n  if (inMatch) {\n    const [, value, listStr] = inMatch;\n    const list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\n    return list.includes(value);\n  }\n  \n  // Handle comparison operators\n  const comparisonMatch = expression.match(/^\"([^\"]*?)\"\\s*(==|!=|<=|>=|<>)\\s*\"([^\"]*?)\"$/);\n  if (comparisonMatch) {\n    const [, left, operator, right] = comparisonMatch;\n    \n    switch (operator) {\n      case '==':\n        return left === right;\n      case '!=':\n      case '<>':\n        return left !== right;\n      case '<=':\n        return left <= right;\n      case '>=':\n        return left >= right;\n      default:\n        return false;\n    }\n  }\n  \n  // Handle simple boolean expressions (just the token value)\n  if (expression === '\"\"' || expression === 'false' || expression === '0') {\n    return false;\n  }\n  \n  return true; // Default to true for non-empty values\n}\n\n/**\n * Processes conditional blocks in template strings\n */\nfunction processConditionalTemplate(template: string, tokenValues: Record<string, string>, suppressWarnings: boolean): { result: string; warnings: string[] } {\n  const warnings: string[] = [];\n  let result = template;\n  \n  // Process conditional expressions by finding balanced braces\n  let pos = 0;\n  while (pos < result.length) {\n    const startPos = result.indexOf('{$', pos);\n    if (startPos === -1) break;\n    \n    // Check if this looks like a conditional (contains ? and :)\n    let braceCount = 0;\n    let endPos = startPos;\n    let foundQuestion = false;\n    let foundColon = false;\n    \n    for (let i = startPos; i < result.length; i++) {\n      const char = result[i];\n      if (char === '{') braceCount++;\n      else if (char === '}') braceCount--;\n      else if (char === '?' && braceCount === 1) foundQuestion = true;\n      else if (char === ':' && braceCount === 1 && foundQuestion) foundColon = true;\n      \n      if (braceCount === 0) {\n        endPos = i;\n        break;\n      }\n    }\n    \n    if (foundQuestion && foundColon) {\n      // This is a conditional expression\n      const fullMatch = result.substring(startPos, endPos + 1);\n      const expression = fullMatch.slice(2, -1); // Remove {$ and }\n      \n      const evalResult = evaluateConditional(expression, tokenValues);\n      \n      if (!evalResult.hasValidTokens && !suppressWarnings) {\n        warnings.push(`Invalid tokens in conditional expression \"${expression}\": ${evalResult.invalidTokens.join(', ')}`);\n      }\n      \n      // Extract the true and false values from the ternary\n      const ternaryMatch = expression.match(/^(.+?)\\s*\\?\\s*'(.*?)'\\s*:\\s*'(.*?)'$/);\n      if (ternaryMatch) {\n        const [, conditionPart, trueValue, falseValue] = ternaryMatch;\n        // Evaluate only the condition part, not the entire ternary expression\n        const conditionResult = evaluateConditional(conditionPart, tokenValues);\n        const replacementValue = conditionResult.condition ? trueValue : falseValue;\n        result = result.substring(0, startPos) + replacementValue + result.substring(endPos + 1);\n        pos = startPos + replacementValue.length;\n      } else {\n        // Fallback: remove the conditional block if malformed\n        result = result.substring(0, startPos) + result.substring(endPos + 1);\n        pos = startPos;\n      }\n    } else {\n      pos = startPos + 2; // Move past this {$ and continue looking\n    }\n  }\n  \n  return { result, warnings };\n}\n\n/**\n * Processes template fragments to handle conditional keys\n */\nfunction processFragmentTemplates(\n  fragmentTemplates: Record<string, string>, \n  tokenValues: Record<string, string>, \n  suppressWarnings: boolean\n): { processedFragments: Record<string, string>; warnings: string[] } {\n  const processedFragments: Record<string, string> = {};\n  const allWarnings: string[] = [];\n  \n  for (const [key, template] of Object.entries(fragmentTemplates)) {\n    // Check if the key itself contains a conditional\n    const keyConditionalMatch = key.match(/^\\{\\$([^}]+\\s*\\?\\s*[^}]+\\s*:\\s*[^}]+)\\}(.*)$/);\n    \n    if (keyConditionalMatch) {\n      const [, expression, keyRemainder] = keyConditionalMatch;\n      const evalResult = evaluateConditional(expression, tokenValues);\n      \n      if (!evalResult.hasValidTokens && !suppressWarnings) {\n        allWarnings.push(`Invalid tokens in conditional key \"${key}\": ${evalResult.invalidTokens.join(', ')}`);\n      }\n      \n      // Only include this fragment if the condition is true\n      if (evalResult.condition) {\n        // Extract the actual key name from the ternary expression\n        const ternaryMatch = expression.match(/^(.+?)\\s*\\?\\s*'([^']*?)'\\s*:\\s*'([^']*?)'$/);\n        if (ternaryMatch) {\n          const [, , trueValue] = ternaryMatch;\n          const actualKey = trueValue + keyRemainder;\n          processedFragments[actualKey] = template;\n        }\n      }\n      // If condition is false, this fragment is omitted entirely\n    } else {\n      // Regular key without conditional\n      processedFragments[key] = template;\n    }\n  }\n  \n  return { processedFragments, warnings: allWarnings };\n}\n\n/**\n * This function is called when your extension is activated. Your extension is activated\n * the very first time the command is executed.\n */\nexport function activate(context: vscode.ExtensionContext) {\n  // Register commands for both extension and supplement modes. Each will call\n  // the shared handler with the appropriate mode string.\n  // This allows the extension to be used from the command palette or context menu.\n  // The commands are registered with the context so they can be disposed of when the extension is deactivated.\n  // The commands are also added to the context menu for easy access.\n  // The context variable 'kahua.showInContextMenu' is set to true to enable\n  // the context menu items when the editor has focus and a selection is made.\n  vscode.commands.executeCommand('setContext', 'kahua.showInContextMenu', true);\n  \n  context.subscriptions.push(\n    vscode.commands.registerCommand('kahua.createExtensionAttributes', () => handleSelection('extension')),\n    vscode.commands.registerCommand('kahua.createSupplementAttributes', () => handleSelection('supplement')),\n    vscode.commands.registerCommand('kahua.insertTokenTemplate', () => insertTokenTemplate()),\n    vscode.commands.registerCommand('kahua.insertTokenSnippet', () => insertTokenSnippet())\n  );\n}\n\n/**\n * This function is called when your extension is deactivated. Nothing to clean up\n * at the moment, but the function is required by VS Code's API.\n */\nexport function deactivate() {\n  /* no‑op */\n}\n\n/**\n * Handles the logic of reading the current selection and generating XML snippets\n * based on the provided mode. Validates configuration and selection, then generates\n * XML using configurable tokens and fragments.\n *\n * @param mode Determines which prefix configuration key to use: \"extension\" or \"supplement\".\n */\nasync function handleSelection(mode: 'extension' | 'supplement'): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    // Validate configuration\n    const config = vscode.workspace.getConfiguration();\n    \n    // Get warning suppression setting\n    const suppressWarnings = config.get<boolean>('kahua.suppressInvalidConditionWarnings') || false;\n    \n    // Get and validate token names\n    const tokenNamesConfig = config.get<string>('kahua.tokenNames');\n    if (!tokenNamesConfig || typeof tokenNamesConfig !== 'string' || tokenNamesConfig.trim() === '') {\n      throw new Error('kahua.tokenNames is not defined or is empty. Please configure token names in your settings.');\n    }\n    \n    // Parse token names and their default values\n    const tokenConfigs = tokenNamesConfig.split(',').map(t => t.trim()).filter(Boolean);\n    if (tokenConfigs.length === 0) {\n      throw new Error('kahua.tokenNames contains no valid token names. Please provide comma-separated token names.');\n    }\n    \n    // Parse tokens with optional default values (format: \"tokenName\" or \"tokenName:defaultValue\")\n    const tokenNames: string[] = [];\n    const tokenDefaults: Record<string, string> = {};\n    \n    for (const tokenConfig of tokenConfigs) {\n      const [tokenName, defaultValue] = tokenConfig.split(':', 2);\n      if (!tokenName) {\n        throw new Error(`Invalid token configuration: \"${tokenConfig}\". Token names cannot be empty.`);\n      }\n      tokenNames.push(tokenName);\n      tokenDefaults[tokenName] = defaultValue || ''; // Use provided default or empty string\n    }\n    \n    // Get and validate fragments\n    const fragmentTemplates = config.get<Record<string, string>>('kahua.fragments');\n    if (!fragmentTemplates || typeof fragmentTemplates !== 'object' || Object.keys(fragmentTemplates).length === 0) {\n      throw new Error('kahua.fragments is not defined or is empty. Please configure fragment templates in your settings.');\n    }\n    \n    // Validate that fragments contain valid templates\n    for (const [key, template] of Object.entries(fragmentTemplates)) {\n      if (!template || typeof template !== 'string') {\n        throw new Error(`Fragment '${key}' has an invalid template. All fragments must be non-empty strings.`);\n      }\n    }\n\n    // Validate selection\n    const selection = editor.document.getText(editor.selection);\n    if (!selection || selection.trim() === '') {\n      throw new Error('No text selected. Please select one or more lines of text to generate attributes.');\n    }\n    \n    const lines = selection.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n    if (lines.length === 0) {\n      throw new Error('Selected text contains no valid lines. Please select text with content.');\n    }\n\n    // Process each line\n    const expanded: Record<string, string[]> = {};\n    const allTokenData: Array<Record<string, string>> = [];\n    const allWarnings: string[] = [];\n    \n    for (const line of lines) {\n      const rawParts = line.split(','); // Keep original whitespace, allow empty parts\n      \n      // Build token values for this line\n      const rawTokenValues: Record<string, string> = {};\n      const cleanTokenValues: Record<string, string> = {};\n      \n      for (let i = 0; i < tokenNames.length; i++) {\n        const tokenName = tokenNames[i];\n        const rawPart = rawParts[i] || '';\n        const trimmedPart = rawPart.trim();\n        \n        rawTokenValues[tokenName] = rawPart || tokenDefaults[tokenName];\n        cleanTokenValues[tokenName] = cleanTokenValue(trimmedPart || tokenDefaults[tokenName]);\n      }\n      \n      // Store token data for the table\n      allTokenData.push({ ...cleanTokenValues });\n\n      // Process fragment templates with conditional support\n      const { processedFragments, warnings: fragmentWarnings } = processFragmentTemplates(fragmentTemplates, cleanTokenValues, suppressWarnings);\n      allWarnings.push(...fragmentWarnings);\n\n      // Apply token replacement for all processed fragments\n      for (const [key, template] of Object.entries(processedFragments)) {\n        // First process conditional expressions in the template\n        const { result: conditionalProcessed, warnings: conditionalWarnings } = processConditionalTemplate(template, cleanTokenValues, suppressWarnings);\n        allWarnings.push(...conditionalWarnings);\n        \n        let rendered = conditionalProcessed;\n        \n        // Handle whitespace-controlled token replacement with $ prefix\n        for (const [tokenName, cleanValue] of Object.entries(cleanTokenValues)) {\n          const rawValue = rawTokenValues[tokenName];\n          \n          // Replace {$token:friendly} - preserves original whitespace/formatting\n          rendered = rendered.replaceAll(`{$${tokenName}:friendly}`, rawValue);\n          \n          // Replace {$token:internal} - uses cleaned value (internal whitespace removed)\n          rendered = rendered.replaceAll(`{$${tokenName}:internal}`, cleanValue);\n          \n          // Replace {$token} - default behavior (uses cleaned value)\n          rendered = rendered.replaceAll(`{$${tokenName}}`, cleanValue);\n        }\n        \n        (expanded[key] ??= []).push(rendered);\n      }\n    }\n\n    // Show warnings if any and not suppressed\n    if (allWarnings.length > 0 && !suppressWarnings) {\n      vscode.window.showWarningMessage(`Kahua: ${allWarnings.join('; ')}`);\n    }\n\n    // Create token table\n    const tokenTable = createTokenTable(tokenNames, allTokenData, tokenDefaults);\n\n    // Join each category of snippets together\n    const fragmentsXml = Object.entries(expanded)\n      .map(([key, lines]: [string, string[]]) =>\n        `<!-- ${key} -->\\n${lines.join('\\n')}`\n      ).join('\\n\\n');\n    \n    const generatedXml = `${tokenTable}\\n\\n${fragmentsXml}`;\n      \n    // Get the output target setting\n    const outputTarget = config.get<string>('kahua.outputTarget') || 'newEditor';\n\n    if (outputTarget === 'newEditor') {\n      // Open in new editor window\n      const newDocument = await vscode.workspace.openTextDocument({\n        content: generatedXml,\n        language: 'xml'\n      });\n\n      await vscode.window.showTextDocument(newDocument, {\n        viewColumn: vscode.ViewColumn.Beside,\n        preview: false\n      });\n\n      vscode.window.showInformationMessage(`Kahua: Generated ${mode} attributes in new editor window`);\n    } else {\n      // Copy to clipboard\n      await vscode.env.clipboard.writeText(generatedXml);\n      vscode.window.showInformationMessage(`Kahua: Generated ${mode} attributes copied to clipboard`);\n    }\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Attribute Generator: ${message}`);\n  }\n}\n\n/**\n * Creates a table showing token names and their values from the processed lines\n */\nfunction createTokenTable(tokenNames: string[], tokenData: Array<Record<string, string>>, tokenDefaults: Record<string, string>): string {\n  if (tokenData.length === 0) {\n    return '<!-- No token data -->';\n  }\n  \n  const header = `| Token | Default | ${tokenData.map((_, i) => `Line ${i + 1}`).join(' | ')} |`;\n  const separator = `|${'-'.repeat(7)}|${'-'.repeat(9)}|${tokenData.map(() => '-'.repeat(8)).join('|')}|`;\n  \n  const rows = tokenNames.map(tokenName => {\n    const defaultValue = tokenDefaults[tokenName] || '';\n    const values = tokenData.map(data => data[tokenName] || '');\n    return `| ${tokenName} | ${defaultValue} | ${values.join(' | ')} |`;\n  });\n  \n  return `<!-- Token Configuration and Values Table -->\\n${header}\\n${separator}\\n${rows.join('\\n')}`;\n}\n\n/**\n * Inserts a token template as a comment showing the expected token order\n */\nasync function insertTokenTemplate(): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    // Get current token configuration\n    const config = vscode.workspace.getConfiguration();\n    const tokenNamesConfig = config.get<string>('kahua.tokenNames');\n    \n    if (!tokenNamesConfig || typeof tokenNamesConfig !== 'string' || tokenNamesConfig.trim() === '') {\n      throw new Error('kahua.tokenNames is not configured. Please configure token names in your settings.');\n    }\n\n    // Parse token names and show defaults where available\n    const tokenConfigs = tokenNamesConfig.split(',').map(t => t.trim()).filter(Boolean);\n    const tokenDisplays = tokenConfigs.map(tokenConfig => {\n      const [tokenName, defaultValue] = tokenConfig.split(':', 2);\n      return defaultValue ? `${tokenName}:${defaultValue}` : tokenName;\n    });\n\n    const templateText = `// Template: ${tokenDisplays.join(', ')}\\n`;\n    \n    // Insert at cursor position\n    const position = editor.selection.active;\n    await editor.edit(editBuilder => {\n      editBuilder.insert(position, templateText);\n    });\n\n    vscode.window.showInformationMessage('Kahua: Token template inserted');\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Token Template: ${message}`);\n  }\n}\n\n/**\n * Inserts a token snippet with tab stops for each token position\n */\nasync function insertTokenSnippet(): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    // Get current token configuration\n    const config = vscode.workspace.getConfiguration();\n    const tokenNamesConfig = config.get<string>('kahua.tokenNames');\n    \n    if (!tokenNamesConfig || typeof tokenNamesConfig !== 'string' || tokenNamesConfig.trim() === '') {\n      throw new Error('kahua.tokenNames is not configured. Please configure token names in your settings.');\n    }\n\n    // Parse token names and create snippet with tab stops that allow typeover of commas\n    const tokenConfigs = tokenNamesConfig.split(',').map(t => t.trim()).filter(Boolean);\n    const snippetParts: string[] = [];\n    let tabStopIndex = 1;\n    \n    for (let i = 0; i < tokenConfigs.length; i++) {\n      const [tokenName, defaultValue] = tokenConfigs[i].split(':', 2);\n      const placeholder = defaultValue || tokenName;\n      \n      // Add the token placeholder\n      snippetParts.push(`\\${${tabStopIndex}:${placeholder}}`);\n      tabStopIndex++;\n      \n      // Add comma as a typeover placeholder (except for the last token)\n      if (i < tokenConfigs.length - 1) {\n        snippetParts.push(`\\${${tabStopIndex}:, }`);\n        tabStopIndex++;\n      }\n    }\n\n    const snippetText = snippetParts.join('');\n    const snippet = new vscode.SnippetString(snippetText);\n    \n    // Insert snippet at cursor position\n    await editor.insertSnippet(snippet);\n\n    vscode.window.showInformationMessage('Kahua: Token snippet inserted');\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Token Snippet: ${message}`);\n  }\n}"]}