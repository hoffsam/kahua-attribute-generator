{"version":3,"file":"extension.js","sourceRoot":"","sources":["../src/extension.ts"],"names":[],"mappings":"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","sourcesContent":["import * as vscode from 'vscode';\n\n/**\n * Represents a conditional expression result\n */\ninterface ConditionalResult {\n  condition: boolean;\n  hasValidTokens: boolean;\n  invalidTokens: string[];\n}\n\n/**\n * Configuration interfaces for the new system\n */\ninterface TokenNameDefinition {\n  id: string;\n  name: string;\n  type: 'header' | 'table';\n  tokens: string;\n}\n\ninterface FragmentDefinition {\n  id: string;\n  name: string;\n  type?: 'grouped' | 'table'; // Default is 'grouped'\n  tokenReferences: string[];\n  fragments: Record<string, string | Record<string, string>>;\n}\n\ninterface MenuOption {\n  name: string;\n  fragments: string[];\n}\n\n/**\n * Parsed token information\n */\ninterface ParsedToken {\n  name: string;\n  defaultValue: string;\n}\n\n\n/**\n * Converts a token value to PascalCase by removing spaces and special characters\n * and capitalizing the first letter of each word\n */\nfunction toPascalCase(value: string): string {\n  if (!value) return value;\n  \n  // Split on word boundaries (spaces, punctuation, etc.) and filter out empty strings\n  return value\n    .split(/[^a-zA-Z0-9]+/)\n    .filter(word => word.length > 0)\n    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n    .join('');\n}\n\n/**\n * Converts a token value to TitleCase following standard capitalization rules\n */\nfunction toTitleCase(value: string): string {\n  if (!value) return value;\n  \n  // Words that should remain lowercase (articles, short prepositions, conjunctions)\n  const lowercaseWords = new Set([\n    'a', 'an', 'the', 'and', 'or', 'but', 'nor', 'yet', 'so',\n    'in', 'on', 'at', 'by', 'for', 'of', 'to', 'up', 'as'\n  ]);\n  \n  // Split into words while preserving spaces\n  const words = value.toLowerCase().split(/(\\s+)/);\n  \n  return words.map((word, index) => {\n    // Preserve whitespace as-is\n    if (/^\\s+$/.test(word)) {\n      return word;\n    }\n    \n    // Always capitalize first and last word\n    const isFirstWord = index === 0 || words.slice(0, index).every(w => /^\\s+$/.test(w));\n    const isLastWord = index === words.length - 1 || words.slice(index + 1).every(w => /^\\s+$/.test(w));\n    \n    if (isFirstWord || isLastWord || !lowercaseWords.has(word.toLowerCase())) {\n      return word.charAt(0).toUpperCase() + word.slice(1);\n    }\n    \n    return word;\n  }).join('');\n}\n\n/**\n * Escapes XML special characters in a string\n */\nfunction escapeXml(value: string): string {\n  if (!value) return value;\n  \n  return value\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\n/**\n * Formats XML content with proper indentation\n * Note: This is a simple formatter designed for the extension's typical output structure\n */\nfunction formatXml(xml: string, indentSize: number = 2): string {\n  if (!xml || xml.trim() === '') return xml;\n  \n  const lines = xml.split(/\\r?\\n/);\n  const formatted: string[] = [];\n  const indent = ' '.repeat(indentSize);\n  \n  // For the extension's output, we mainly want to:\n  // 1. Preserve comments and table data as-is\n  // 2. Indent nested XML elements\n  // 3. Keep self-closing tags at the base level\n  \n  for (const line of lines) {\n    const trimmed = line.trim();\n    if (!trimmed) continue; // Skip empty lines\n    \n    // Handle comments and non-XML content - no indentation changes\n    if (trimmed.startsWith('<!--') || !trimmed.startsWith('<')) {\n      formatted.push(trimmed);\n      continue;\n    }\n    \n    // For XML tags, determine indentation based on content\n    if (trimmed.startsWith('<DataTag') && !trimmed.endsWith('/>')) {\n      // DataTag opening - no indent for the tag itself\n      formatted.push(trimmed);\n    } else if (trimmed.startsWith('</DataTag>')) {\n      // DataTag closing - no indent\n      formatted.push(trimmed);\n    } else if (trimmed.startsWith('<Key />') || trimmed.startsWith('<Value ')) {\n      // Nested elements within DataTag or LookupList - indent\n      formatted.push(indent + trimmed);\n    } else if (trimmed.startsWith('<LookupList') && !trimmed.endsWith('/>')) {\n      // LookupList opening - no indent\n      formatted.push(trimmed);\n    } else if (trimmed.startsWith('</LookupList>')) {\n      // LookupList closing - no indent  \n      formatted.push(trimmed);\n    } else {\n      // All other XML elements (Attribute, Label, Field, etc.) - no indent\n      formatted.push(trimmed);\n    }\n  }\n  \n  return formatted.join('\\n');\n}\n\n/**\n * Formats a collection of XML fragments with section headers and proper indentation\n */\nfunction formatFragmentCollection(fragments: { [key: string]: string[] }, indentSize: number = 2): string {\n  const sections: string[] = [];\n  \n  for (const [sectionName, fragmentList] of Object.entries(fragments)) {\n    if (fragmentList.length === 0) continue;\n    \n    // Add section header comment\n    sections.push(`<!-- ${sectionName} -->`);\n    \n    // Format each fragment in the section\n    const formattedFragments = fragmentList.map(fragment => formatXml(fragment, indentSize));\n    sections.push(formattedFragments.join('\\n'));\n  }\n  \n  return sections.join('\\n\\n');\n}\n\n/**\n * Applies transformation to a token value based on the transformation type\n */\nfunction applyTokenTransformation(value: string, transformation: string): string {\n  if (!value) return value;\n  \n  switch (transformation.toLowerCase()) {\n    case 'friendly':\n      return escapeXml(toTitleCase(value)); // Apply TitleCase and XML escape\n    case 'internal':\n      return toPascalCase(value); // Convert to PascalCase (no XML escaping needed for identifiers)\n    case 'upper':\n      return escapeXml(value.toUpperCase()); // Convert to uppercase and XML escape\n    case 'lower':\n      return escapeXml(value.toLowerCase()); // Convert to lowercase and XML escape\n    case 'slug':\n      return toPascalCase(value) + '_'; // Convert to PascalCase and append underscore\n    case 'raw':\n      return value; // Leave exactly as user typed it (no processing)\n    default:\n      return toPascalCase(value); // Default: PascalCase (no XML escaping for identifiers)\n  }\n}\n\n/**\n * Evaluates a conditional expression with token values\n */\nfunction evaluateConditional(expression: string, tokenValues: Record<string, string>): ConditionalResult {\n  const invalidTokens: string[] = [];\n  let hasValidTokens = true;\n  \n  // Replace tokens in the expression with their values\n  let processedExpression = expression;\n  \n  // Find all token references in the expression\n  const tokenPattern = /\\{\\$(\\w+)\\}/g;\n  let match;\n  while ((match = tokenPattern.exec(expression)) !== null) {\n    const tokenName = match[1];\n    const tokenValue = tokenValues[tokenName];\n    \n    if (tokenValue === undefined || tokenValue === '') {\n      invalidTokens.push(tokenName);\n      hasValidTokens = false;\n      // Replace with empty string for evaluation\n      processedExpression = processedExpression.replace(match[0], '\"\"');\n    } else {\n      // Replace with quoted string value for evaluation\n      processedExpression = processedExpression.replace(match[0], `\"${tokenValue.replace(/\"/g, '\\\\\"')}\"`);\n    }\n  }\n  \n  try {\n    // Parse and evaluate the conditional expression\n    const result = evaluateExpression(processedExpression);\n    return {\n      condition: result,\n      hasValidTokens,\n      invalidTokens\n    };\n  } catch (error) {\n    return {\n      condition: false,\n      hasValidTokens: false,\n      invalidTokens\n    };\n  }\n}\n\n/**\n * Safely evaluates a conditional expression\n * Supports: ==, !=, <=, >=, <>, in, not in, ternary operator, &&, ||, parentheses\n */\nfunction evaluateExpression(expression: string): boolean {\n  // Remove extra whitespace\n  expression = expression.trim();\n  \n  // Handle ternary operator (condition ? value : fallback) - need to find the main ? and : carefully\n  const ternaryResult = findTernaryOperator(expression);\n  if (ternaryResult) {\n    const { condition, trueValue, falseValue } = ternaryResult;\n    const conditionResult = evaluateExpression(condition);\n    return conditionResult;\n  }\n  \n  // Handle logical OR (||) - lowest precedence\n  const orResult = findLogicalOperator(expression, '||');\n  if (orResult) {\n    const { left, right } = orResult;\n    return evaluateExpression(left) || evaluateExpression(right);\n  }\n  \n  // Handle logical AND (&&) - higher precedence than OR\n  const andResult = findLogicalOperator(expression, '&&');\n  if (andResult) {\n    const { left, right } = andResult;\n    return evaluateExpression(left) && evaluateExpression(right);\n  }\n  \n  // Handle parentheses\n  if (expression.startsWith('(') && expression.endsWith(')')) {\n    const inner = expression.slice(1, -1).trim();\n    if (isBalancedParentheses(inner)) {\n      return evaluateExpression(inner);\n    }\n  }\n  \n  // Handle 'not in' operator\n  const notInMatch = expression.match(/^\"([^\"]*?)\"\\s+not\\s+in\\s+\\(([^)]+)\\)$/i);\n  if (notInMatch) {\n    const [, value, listStr] = notInMatch;\n    const list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\n    return !list.includes(value);\n  }\n  \n  // Handle 'in' operator\n  const inMatch = expression.match(/^\"([^\"]*?)\"\\s+in\\s+\\(([^)]+)\\)$/i);\n  if (inMatch) {\n    const [, value, listStr] = inMatch;\n    const list = listStr.split(',').map(item => item.trim().replace(/^['\"]|['\"]$/g, ''));\n    return list.includes(value);\n  }\n  \n  // Handle comparison operators\n  const comparisonMatch = expression.match(/^\"([^\"]*?)\"\\s*(==|!=|<=|>=|<>)\\s*\"([^\"]*?)\"$/);\n  if (comparisonMatch) {\n    const [, left, operator, right] = comparisonMatch;\n    \n    switch (operator) {\n      case '==':\n        return left === right;\n      case '!=':\n      case '<>':\n        return left !== right;\n      case '<=':\n        return left <= right;\n      case '>=':\n        return left >= right;\n      default:\n        return false;\n    }\n  }\n  \n  // Handle simple boolean expressions (just the token value)\n  if (expression === '\"\"' || expression === 'false' || expression === '0') {\n    return false;\n  }\n  \n  return true; // Default to true for non-empty values\n}\n\n/**\n * Helper function to check if parentheses are balanced in an expression\n */\nfunction isBalancedParentheses(expression: string): boolean {\n  let count = 0;\n  for (const char of expression) {\n    if (char === '(') count++;\n    else if (char === ')') count--;\n    if (count < 0) return false;\n  }\n  return count === 0;\n}\n\n/**\n * Finds the main ternary operator (? :) in an expression, respecting nesting and quotes\n */\nfunction findTernaryOperator(expression: string): { condition: string; trueValue: string; falseValue: string } | null {\n  let parenCount = 0;\n  let questionPos = -1;\n  let colonPos = -1;\n  let inQuotes = false;\n  let quoteChar = '';\n  \n  // Find the main ? and : operators (not inside parentheses or quotes)\n  for (let i = 0; i < expression.length; i++) {\n    const char = expression[i];\n    const prevChar = i > 0 ? expression[i - 1] : '';\n    \n    // Handle quoted strings\n    if ((char === '\"' || char === \"'\") && prevChar !== '\\\\') {\n      if (!inQuotes) {\n        inQuotes = true;\n        quoteChar = char;\n      } else if (char === quoteChar) {\n        inQuotes = false;\n        quoteChar = '';\n      }\n    }\n    \n    // Only process operators when not inside quotes\n    if (!inQuotes) {\n      if (char === '(') parenCount++;\n      else if (char === ')') parenCount--;\n      else if (char === '?' && parenCount === 0 && questionPos === -1) {\n        questionPos = i;\n      } else if (char === ':' && parenCount === 0 && questionPos !== -1 && colonPos === -1) {\n        colonPos = i;\n        break;\n      }\n    }\n  }\n  \n  if (questionPos !== -1 && colonPos !== -1) {\n    const condition = expression.substring(0, questionPos).trim();\n    const trueValue = expression.substring(questionPos + 1, colonPos).trim();\n    const falseValue = expression.substring(colonPos + 1).trim();\n    return { condition, trueValue, falseValue };\n  }\n  \n  return null;\n}\n\n/**\n * Finds logical operators (&&, ||) in an expression, respecting nesting\n */\nfunction findLogicalOperator(expression: string, operator: '&&' | '||'): { left: string; right: string } | null {\n  let parenCount = 0;\n  const opLength = operator.length;\n  \n  // Find the rightmost occurrence of the operator (right-to-left for correct precedence)\n  for (let i = expression.length - opLength; i >= 0; i--) {\n    const char = expression[i];\n    const nextChar = expression[i + 1];\n    \n    if (char === ')') parenCount++;\n    else if (char === '(') parenCount--;\n    else if (parenCount === 0 && expression.substr(i, opLength) === operator) {\n      const left = expression.substring(0, i).trim();\n      const right = expression.substring(i + opLength).trim();\n      if (left && right) {\n        return { left, right };\n      }\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Processes PowerShell-style string interpolation tokens $(token) and $(token|transformation)\n */\nfunction processStringInterpolation(\n  template: string, \n  cleanTokenValues: Record<string, string>,\n  rawTokenValues: Record<string, string>\n): string {\n  let result = template;\n  \n  // Process $(token) and $(token|transformation) patterns\n  const interpolationPattern = /\\$\\((\\w+)(?:\\|([^)]+))?\\)/g;\n  let match;\n  \n  while ((match = interpolationPattern.exec(result)) !== null) {\n    const fullMatch = match[0];\n    const tokenName = match[1];\n    const transformation = match[2] || 'default';\n    \n    const rawValue = rawTokenValues[tokenName] || '';\n    const transformedValue = applyTokenTransformation(rawValue, transformation);\n    \n    result = result.replace(fullMatch, transformedValue);\n    // Reset regex to continue searching from beginning since we modified the string\n    interpolationPattern.lastIndex = 0;\n  }\n  \n  return result;\n}\n\n/**\n * Processes conditional blocks in template strings with improved parsing\n */\nfunction processConditionalTemplate(template: string, tokenValues: Record<string, string>, suppressWarnings: boolean): { result: string; warnings: string[] } {\n  const warnings: string[] = [];\n  let result = template;\n  \n  // Process conditional expressions by finding balanced braces\n  let pos = 0;\n  while (pos < result.length) {\n    const startPos = result.indexOf('{$', pos);\n    if (startPos === -1) break;\n    \n    // Find the matching closing brace, respecting nesting\n    let braceCount = 0;\n    let endPos = startPos;\n    let foundQuestion = false;\n    let foundColon = false;\n    let inQuotes = false;\n    let quoteChar = '';\n    \n    for (let i = startPos; i < result.length; i++) {\n      const char = result[i];\n      const prevChar = i > 0 ? result[i - 1] : '';\n      \n      // Handle quoted strings\n      if ((char === '\"' || char === \"'\") && prevChar !== '\\\\') {\n        if (!inQuotes) {\n          inQuotes = true;\n          quoteChar = char;\n        } else if (char === quoteChar) {\n          inQuotes = false;\n          quoteChar = '';\n        }\n      }\n      \n      if (!inQuotes) {\n        if (char === '{') braceCount++;\n        else if (char === '}') braceCount--;\n        else if (char === '?' && braceCount === 1) foundQuestion = true;\n        else if (char === ':' && braceCount === 1 && foundQuestion) foundColon = true;\n      }\n      // Note: We intentionally ignore $() tokens within strings during conditional parsing\n      // These will be processed later by processStringInterpolation()\n      \n      if (braceCount === 0) {\n        endPos = i;\n        break;\n      }\n    }\n    \n    if (foundQuestion && foundColon) {\n      // This is a conditional expression\n      const fullMatch = result.substring(startPos, endPos + 1);\n      const expression = fullMatch.slice(2, -1); // Remove {$ and }\n      \n      const evalResult = evaluateConditional(expression, tokenValues);\n      \n      if (!evalResult.hasValidTokens && !suppressWarnings) {\n        warnings.push(`Invalid tokens in conditional expression \"${expression}\": ${evalResult.invalidTokens.join(', ')}`);\n      }\n      \n      // Use the improved ternary parsing to extract values\n      const ternaryResult = findTernaryOperator(expression);\n      if (ternaryResult) {\n        const conditionResult = evaluateConditional(ternaryResult.condition, tokenValues);\n        \n        // Remove quotes from true/false values if they exist\n        let trueValue = ternaryResult.trueValue;\n        let falseValue = ternaryResult.falseValue;\n        \n        if ((trueValue.startsWith(\"'\") && trueValue.endsWith(\"'\")) || \n            (trueValue.startsWith('\"') && trueValue.endsWith('\"'))) {\n          trueValue = trueValue.slice(1, -1);\n        }\n        \n        if ((falseValue.startsWith(\"'\") && falseValue.endsWith(\"'\")) || \n            (falseValue.startsWith('\"') && falseValue.endsWith('\"'))) {\n          falseValue = falseValue.slice(1, -1);\n        }\n        \n        const replacementValue = conditionResult.condition ? trueValue : falseValue;\n        result = result.substring(0, startPos) + replacementValue + result.substring(endPos + 1);\n        pos = startPos + replacementValue.length;\n      } else {\n        // Fallback: remove the conditional block if malformed\n        result = result.substring(0, startPos) + result.substring(endPos + 1);\n        pos = startPos;\n      }\n    } else {\n      pos = startPos + 2; // Move past this {$ and continue looking\n    }\n  }\n  \n  return { result, warnings };\n}\n\n/**\n * Processes template fragments to handle conditional keys and nested structures\n */\nfunction processFragmentTemplates(\n  fragmentTemplates: Record<string, string | Record<string, string>>, \n  tokenValues: Record<string, string>, \n  suppressWarnings: boolean\n): { processedFragments: Record<string, string>; warnings: string[] } {\n  const processedFragments: Record<string, string> = {};\n  const allWarnings: string[] = [];\n  \n  for (const [key, template] of Object.entries(fragmentTemplates)) {\n    if (typeof template === 'object') {\n      // Handle nested structure (like body: { Attributes: \"...\", Labels: \"...\" })\n      for (const [subKey, subTemplate] of Object.entries(template)) {\n        const fullKey = `${key} - ${subKey}`;\n        processedFragments[fullKey] = subTemplate;\n      }\n    } else {\n      // Handle flat structure\n      // Check if the key itself contains a conditional\n      const keyConditionalMatch = key.match(/^\\{\\$([^}]+\\s*\\?\\s*[^}]+\\s*:\\s*[^}]+)\\}(.*)$/);\n      \n      if (keyConditionalMatch) {\n        const [, expression, keyRemainder] = keyConditionalMatch;\n        const evalResult = evaluateConditional(expression, tokenValues);\n        \n        if (!evalResult.hasValidTokens && !suppressWarnings) {\n          allWarnings.push(`Invalid tokens in conditional key \"${key}\": ${evalResult.invalidTokens.join(', ')}`);\n        }\n        \n        // Only include this fragment if the condition is true\n        if (evalResult.condition) {\n          // Extract the actual key name from the ternary expression\n          const ternaryMatch = expression.match(/^(.+?)\\s*\\?\\s*'([^']*?)'\\s*:\\s*'([^']*?)'$/);\n          if (ternaryMatch) {\n            const [, , trueValue] = ternaryMatch;\n            const actualKey = trueValue + keyRemainder;\n            processedFragments[actualKey] = template;\n          }\n        }\n        // If condition is false, this fragment is omitted entirely\n      } else {\n        // Regular key without conditional\n        processedFragments[key] = template;\n      }\n    }\n  }\n  \n  return { processedFragments, warnings: allWarnings };\n}\n\n/**\n * This function is called when your extension is activated.\n */\nexport function activate(context: vscode.ExtensionContext) {\n  // Set up context menu visibility\n  vscode.commands.executeCommand('setContext', 'kahua.showInContextMenu', true);\n  \n  // Register attribute generation commands\n  context.subscriptions.push(\n    vscode.commands.registerCommand('kahua.generateAttributesExtension', () => handleSelection(['attributes'])),\n    vscode.commands.registerCommand('kahua.generateAttributesSupplement', () => handleSelection(['supplements'])),\n    vscode.commands.registerCommand('kahua.generateSnippetAttributes', () => generateSnippetForFragments(['attributes'])),\n    vscode.commands.registerCommand('kahua.generateTemplateAttributes', () => generateTemplateForFragments(['attributes']))\n  );\n  \n  // Register lookup generation commands\n  context.subscriptions.push(\n    vscode.commands.registerCommand('kahua.generateLookups', () => handleSelection(['lookups'])),\n    vscode.commands.registerCommand('kahua.generateSnippetLookups', () => generateSnippetForFragments(['lookups'])),\n    vscode.commands.registerCommand('kahua.generateTemplateLookups', () => generateTemplateForFragments(['lookups']))\n  );\n  \n  // Register custom generation commands\n  context.subscriptions.push(\n    vscode.commands.registerCommand('kahua.generateCustom', async () => {\n      const config = vscode.workspace.getConfiguration();\n      const menuOptions = config.get<MenuOption[]>('kahua.menuOptions') || [];\n      \n      if (menuOptions.length === 0) {\n        vscode.window.showErrorMessage('No menu options configured. Please configure kahua.menuOptions in your settings.');\n        return;\n      }\n      \n      const pick = await vscode.window.showQuickPick(\n        menuOptions.map(option => ({\n          label: option.name,\n          fragments: option.fragments\n        })),\n        { \n          placeHolder: 'Select fragment type to generate',\n          title: 'Kahua Custom Fragment Generator'\n        }\n      );\n      \n      if (pick) {\n        await handleSelection(pick.fragments);\n      }\n    }),\n    vscode.commands.registerCommand('kahua.generateSnippetCustom', async () => {\n      const pick = await selectCustomFragments('Select fragments for snippet generation');\n      if (pick) {\n        await generateSnippetForFragments(pick.fragments);\n      }\n    }),\n    vscode.commands.registerCommand('kahua.generateTemplateCustom', async () => {\n      const pick = await selectCustomFragments('Select fragments for template generation');\n      if (pick) {\n        await generateTemplateForFragments(pick.fragments);\n      }\n    })\n  );\n}\n\n\n/**\n * Parses token definitions from configuration string\n */\nfunction parseTokenDefinition(tokens: string): ParsedToken[] {\n  return tokens.split(',')\n    .map(t => t.trim())\n    .filter(Boolean)\n    .map(tokenConfig => {\n      const [tokenName, defaultValue] = tokenConfig.split(':', 2);\n      return {\n        name: tokenName.trim(),\n        defaultValue: defaultValue?.trim() || ''\n      };\n    });\n}\n\n/**\n * Merges token definitions with priority handling\n */\nfunction mergeTokenDefinitions(\n  tokenDefs: TokenNameDefinition[], \n  referencedIds: string[]\n): { headerTokens: ParsedToken[]; tableTokens: ParsedToken[]; tokenDefaults: Record<string, string> } {\n  const headerTokens: ParsedToken[] = [];\n  const tableTokens: ParsedToken[] = [];\n  const tokenDefaults: Record<string, string> = {};\n  const seenTokens = new Set<string>();\n  \n  // Process token definitions in priority order (first referenced has priority)\n  for (const refId of referencedIds) {\n    const tokenDef = tokenDefs.find(def => def.id === refId);\n    if (!tokenDef) continue;\n    \n    const parsedTokens = parseTokenDefinition(tokenDef.tokens);\n    \n    for (const token of parsedTokens) {\n      if (!seenTokens.has(token.name)) {\n        seenTokens.add(token.name);\n        tokenDefaults[token.name] = token.defaultValue;\n        \n        if (tokenDef.type === 'header') {\n          headerTokens.push(token);\n        } else {\n          tableTokens.push(token);\n        }\n      }\n    }\n  }\n  \n  return { headerTokens, tableTokens, tokenDefaults };\n}\n\n/**\n * Splits input text into groups separated by empty lines\n */\nfunction splitIntoGroups(text: string): string[][] {\n  const allLines = text.split(/\\r?\\n/);\n  const groups: string[][] = [];\n  let currentGroup: string[] = [];\n  \n  for (const line of allLines) {\n    if (line.trim() === '') {\n      // Empty line - end current group if it has content\n      if (currentGroup.length > 0) {\n        groups.push(currentGroup);\n        currentGroup = [];\n      }\n    } else {\n      // Non-empty line - add to current group\n      currentGroup.push(line.trim());\n    }\n  }\n  \n  // Add final group if it has content\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n  \n  return groups;\n}\n\n\n/**\n * Creates a properly formatted table with aligned columns\n */\nfunction createFormattedTokenTable(\n  tokenNames: string[],\n  tokenData: Array<Record<string, string>>,\n  tokenDefaults: Record<string, string>,\n  groupNumber: number\n): string {\n  if (tokenData.length === 0) {\n    return `<!-- Group ${groupNumber} - No token data -->`;\n  }\n  \n  // Calculate column widths\n  const columns = ['Token', 'Default', ...tokenData.map((_, i) => `Line ${i + 1}`)];\n  const columnWidths = columns.map(col => col.length);\n  \n  // Update widths based on token names\n  tokenNames.forEach((tokenName, tokenIndex) => {\n    columnWidths[0] = Math.max(columnWidths[0], tokenName.length);\n    \n    const defaultValue = tokenDefaults[tokenName] || '';\n    columnWidths[1] = Math.max(columnWidths[1], defaultValue.length);\n    \n    tokenData.forEach((data, dataIndex) => {\n      const value = data[tokenName] || '';\n      columnWidths[dataIndex + 2] = Math.max(columnWidths[dataIndex + 2], value.length);\n    });\n  });\n  \n  // Create header\n  const header = '| ' + columns.map((col, i) => col.padEnd(columnWidths[i])).join(' | ') + ' |';\n  const separator = '|' + columnWidths.map(width => '-'.repeat(width + 2)).join('|') + '|';\n  \n  // Create data rows\n  const rows = tokenNames.map(tokenName => {\n    const defaultValue = (tokenDefaults[tokenName] || '').padEnd(columnWidths[1]);\n    const values = tokenData.map((data, i) => (data[tokenName] || '').padEnd(columnWidths[i + 2]));\n    return '| ' + tokenName.padEnd(columnWidths[0]) + ' | ' + defaultValue + ' | ' + values.join(' | ') + ' |';\n  });\n  \n  return `<!-- Group ${groupNumber} Token Configuration and Values Table -->\\n${header}\\n${separator}\\n${rows.join('\\n')}`;\n}\n\n/**\n * Renders a template with token replacement and conditional processing\n */\nfunction renderTemplate(\n  template: string, \n  cleanTokenValues: Record<string, string>,\n  rawTokenValues: Record<string, string>,\n  suppressWarnings: boolean\n): { result: string; warnings: string[] } {\n  const warnings: string[] = [];\n  \n  // Phase 1: Process conditional expressions\n  const { result: conditionalProcessed, warnings: conditionalWarnings } = processConditionalTemplate(\n    template, \n    cleanTokenValues, \n    suppressWarnings\n  );\n  warnings.push(...conditionalWarnings);\n  \n  // Phase 2: Process PowerShell-style string interpolations $(token)\n  let rendered = processStringInterpolation(conditionalProcessed, cleanTokenValues, rawTokenValues);\n  \n  // Phase 3: Handle remaining {$token} transformation-controlled token replacement\n  for (const [tokenName, cleanValue] of Object.entries(cleanTokenValues)) {\n    const rawValue = rawTokenValues[tokenName] || '';\n    \n    // Find all token references with transformations in the rendered template\n    const tokenPattern = new RegExp(`\\\\{\\\\$${tokenName}(?:\\\\|([^}]+))?\\\\}`, 'g');\n    let match;\n    \n    while ((match = tokenPattern.exec(rendered)) !== null) {\n      const fullMatch = match[0];\n      const transformation = match[1] || 'default'; // Use 'default' if no transformation specified\n      const transformedValue = applyTokenTransformation(rawValue, transformation);\n      \n      rendered = rendered.replace(fullMatch, transformedValue);\n      // Reset the regex to continue searching from the beginning since we modified the string\n      tokenPattern.lastIndex = 0;\n    }\n  }\n  \n  return { result: rendered, warnings };\n}\n\n/**\n * Shows quickpick for selecting custom fragments\n */\nasync function selectCustomFragments(placeholder: string): Promise<{ label: string; fragments: string[] } | undefined> {\n  const config = vscode.workspace.getConfiguration();\n  const menuOptions = config.get<MenuOption[]>('kahua.menuOptions') || [];\n  \n  if (menuOptions.length === 0) {\n    vscode.window.showErrorMessage('No menu options configured. Please configure kahua.menuOptions in your settings.');\n    return undefined;\n  }\n  \n  return await vscode.window.showQuickPick(\n    menuOptions.map(option => ({\n      label: option.name,\n      fragments: option.fragments\n    })),\n    { \n      placeHolder: placeholder,\n      title: 'Kahua Custom Fragment Selector'\n    }\n  );\n}\n\n/**\n * Generates and inserts a snippet for the specified fragment types\n */\nasync function generateSnippetForFragments(fragmentIds: string[]): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    const config = vscode.workspace.getConfiguration();\n    const tokenDefinitions = config.get<TokenNameDefinition[]>('kahua.tokenNameDefinitions') || [];\n    const fragmentDefinitions = config.get<FragmentDefinition[]>('kahua.fragmentDefinitions') || [];\n    \n    if (tokenDefinitions.length === 0) {\n      throw new Error('No token name definitions found. Please configure kahua.tokenNameDefinitions in your settings.');\n    }\n    \n    // Find the fragment definitions we need\n    const selectedFragmentDefs = fragmentDefinitions.filter(def => fragmentIds.includes(def.id));\n    if (selectedFragmentDefs.length === 0) {\n      throw new Error(`No matching fragment definitions found for: ${fragmentIds.join(', ')}`);\n    }\n    \n    // Collect all unique token references from selected fragments\n    const allTokenReferences = new Set<string>();\n    selectedFragmentDefs.forEach(def => {\n      def.tokenReferences.forEach(ref => allTokenReferences.add(ref));\n    });\n    \n    // Merge token definitions based on references\n    const { headerTokens, tableTokens } = mergeTokenDefinitions(\n      tokenDefinitions, \n      Array.from(allTokenReferences)\n    );\n\n    // Separate header and table token definitions\n    const snippetLines: string[] = [];\n    let tabStopIndex = 1;\n    let numberOfRows = 0; // Track total rows for message\n    \n    // Create header line if there are header tokens\n    if (headerTokens.length > 0) {\n      const headerParts: string[] = [];\n      \n      for (let i = 0; i < headerTokens.length; i++) {\n        const token = headerTokens[i];\n        const placeholder = token.defaultValue || token.name;\n        \n        // Include comma in the tabstop for proper step-over behavior\n        if (i < headerTokens.length - 1) {\n          headerParts.push(`\\${${tabStopIndex}:${placeholder}}, `);\n        } else {\n          // Last token doesn't need a comma\n          headerParts.push(`\\${${tabStopIndex}:${placeholder}}`);\n        }\n        tabStopIndex++;\n      }\n      \n      snippetLines.push(headerParts.join(''));\n    }\n    \n    // Create table data lines if there are table tokens\n    if (tableTokens.length > 0) {\n      const config = vscode.workspace.getConfiguration();\n      const defaultTableRows = config.get<number>('kahua.defaultSnippetTableRows') || 0;\n      \n      numberOfRows = defaultTableRows;\n      \n      // If default is 0, use current behavior (single row)\n      // If default > 0, prompt user for row count with default value\n      if (defaultTableRows > 0) {\n        // Get the maximum value from configuration schema (fallback to 100 if not found)\n        const maxRows = 100;\n        \n        const userInput = await vscode.window.showInputBox({\n          prompt: `How many table data rows to generate? (1-${maxRows})`,\n          value: defaultTableRows.toString(),\n          validateInput: (value: string) => {\n            const num = parseInt(value);\n            if (isNaN(num) || num < 1 || num > maxRows) {\n              return `Please enter a number between 1 and ${maxRows}`;\n            }\n            return undefined;\n          }\n        });\n        \n        if (userInput === undefined) {\n          // User cancelled the prompt\n          vscode.window.showInformationMessage('Snippet generation cancelled');\n          return;\n        }\n        \n        numberOfRows = parseInt(userInput);\n      } else {\n        // Default behavior: single row\n        numberOfRows = 1;\n      }\n      \n      // Generate the specified number of table rows\n      for (let rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {\n        const tableParts: string[] = [];\n        \n        for (let i = 0; i < tableTokens.length; i++) {\n          const token = tableTokens[i];\n          const placeholder = token.defaultValue || token.name;\n          \n          // Include comma in the tabstop for proper step-over behavior  \n          if (i < tableTokens.length - 1) {\n            tableParts.push(`\\${${tabStopIndex}:${placeholder}}, `);\n          } else {\n            // Last token doesn't need a comma\n            tableParts.push(`\\${${tabStopIndex}:${placeholder}}`);\n          }\n          tabStopIndex++;\n        }\n        \n        snippetLines.push(tableParts.join(''));\n      }\n    }\n    \n    // If no lines were created, show an error\n    if (snippetLines.length === 0) {\n      throw new Error('No header or table token definitions found.');\n    }\n\n    const snippetText = snippetLines.join('\\n');\n    const snippet = new vscode.SnippetString(snippetText);\n    \n    // Insert snippet at cursor position\n    await editor.insertSnippet(snippet);\n\n    const rowText = numberOfRows === 0 \n      ? 'header only' \n      : numberOfRows === 1 \n        ? '1 table row' \n        : `${numberOfRows} table rows`;\n    vscode.window.showInformationMessage(`Kahua: Token snippet inserted for ${fragmentIds.join(', ')} with ${rowText}`);\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Token Snippet: ${message}`);\n  }\n}\n\n/**\n * Generates and inserts a template for the specified fragment types\n */\nasync function generateTemplateForFragments(fragmentIds: string[]): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    const config = vscode.workspace.getConfiguration();\n    const tokenDefinitions = config.get<TokenNameDefinition[]>('kahua.tokenNameDefinitions') || [];\n    const fragmentDefinitions = config.get<FragmentDefinition[]>('kahua.fragmentDefinitions') || [];\n    \n    if (tokenDefinitions.length === 0) {\n      throw new Error('No token name definitions found. Please configure kahua.tokenNameDefinitions in your settings.');\n    }\n    \n    // Find the fragment definitions we need\n    const selectedFragmentDefs = fragmentDefinitions.filter(def => fragmentIds.includes(def.id));\n    if (selectedFragmentDefs.length === 0) {\n      throw new Error(`No matching fragment definitions found for: ${fragmentIds.join(', ')}`);\n    }\n    \n    // Collect all unique token references from selected fragments\n    const allTokenReferences = new Set<string>();\n    selectedFragmentDefs.forEach(def => {\n      def.tokenReferences.forEach(ref => allTokenReferences.add(ref));\n    });\n    \n    // Merge token definitions based on references\n    const { headerTokens, tableTokens } = mergeTokenDefinitions(\n      tokenDefinitions, \n      Array.from(allTokenReferences)\n    );\n\n    // Build template text showing all token definitions\n    const templateLines: string[] = [];\n    templateLines.push(`// Token Template for ${fragmentIds.join(', ')}:`);\n    \n    if (headerTokens.length > 0) {\n      const headerTokenDisplays = headerTokens.map(token => \n        token.defaultValue ? `${token.name}:${token.defaultValue}` : token.name\n      );\n      templateLines.push(`// Header tokens: ${headerTokenDisplays.join(', ')}`);\n    }\n    \n    if (tableTokens.length > 0) {\n      const tableTokenDisplays = tableTokens.map(token => \n        token.defaultValue ? `${token.name}:${token.defaultValue}` : token.name\n      );\n      templateLines.push(`// Table tokens: ${tableTokenDisplays.join(', ')}`);\n    }\n    \n    templateLines.push('//');\n    templateLines.push('// Usage: First line contains header tokens, subsequent lines contain table tokens');\n    templateLines.push('');\n\n    const templateText = templateLines.join('\\n');\n    \n    // Insert at cursor position\n    const position = editor.selection.active;\n    await editor.edit(editBuilder => {\n      editBuilder.insert(position, templateText);\n    });\n\n    vscode.window.showInformationMessage(`Kahua: Token template inserted for ${fragmentIds.join(', ')}`);\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Token Template: ${message}`);\n  }\n}\n\n/**\n * This function is called when your extension is deactivated.\n */\nexport function deactivate() {\n  // Extension cleanup handled by VS Code context subscriptions\n}\n\n/**\n * Handles the logic of reading the current selection and generating XML snippets\n * based on the provided fragment IDs. Validates configuration and selection, then generates\n * XML using configurable tokens and fragments.\n *\n * @param fragmentIds Array of fragment definition IDs to process\n */\nasync function handleSelection(fragmentIds: string[]): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    vscode.window.showErrorMessage('No active editor found');\n    return;\n  }\n\n  try {\n    const config = vscode.workspace.getConfiguration();\n    const suppressWarnings = config.get<boolean>('kahua.suppressInvalidConditionWarnings') || false;\n    \n    // Get configuration arrays\n    const tokenDefinitions = config.get<TokenNameDefinition[]>('kahua.tokenNameDefinitions') || [];\n    const fragmentDefinitions = config.get<FragmentDefinition[]>('kahua.fragmentDefinitions') || [];\n    \n    if (tokenDefinitions.length === 0) {\n      throw new Error('No token name definitions found. Please configure kahua.tokenNameDefinitions in your settings.');\n    }\n    \n    if (fragmentDefinitions.length === 0) {\n      throw new Error('No fragment definitions found. Please configure kahua.fragmentDefinitions in your settings.');\n    }\n    \n    // Find the fragment definitions we need to process\n    const selectedFragmentDefs = fragmentDefinitions.filter(def => fragmentIds.includes(def.id));\n    if (selectedFragmentDefs.length === 0) {\n      throw new Error(`No matching fragment definitions found for: ${fragmentIds.join(', ')}`);\n    }\n    \n    // Collect all unique token references from selected fragments\n    const allTokenReferences = new Set<string>();\n    selectedFragmentDefs.forEach(def => {\n      def.tokenReferences.forEach(ref => allTokenReferences.add(ref));\n    });\n    \n    // Merge token definitions based on references\n    const { headerTokens, tableTokens, tokenDefaults } = mergeTokenDefinitions(\n      tokenDefinitions, \n      Array.from(allTokenReferences)\n    );\n    \n    // Validate selection\n    const selection = editor.document.getText(editor.selection);\n    if (!selection || selection.trim() === '') {\n      throw new Error('No text selected. Please select one or more lines of text to generate attributes.');\n    }\n    \n    // Split into groups by empty lines\n    const groups = splitIntoGroups(selection);\n    if (groups.length === 0) {\n      throw new Error('Selected text contains no valid groups. Please select text with content.');\n    }\n\n    // Process each group\n    const allWarnings: string[] = [];\n    const outputSections: string[] = [];\n    \n    for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n      const group = groups[groupIndex];\n      \n      // Process header tokens (first line if any header tokens exist)\n      const headerTokenValues: Record<string, string> = {};\n      const headerRawValues: Record<string, string> = {};\n      let dataLines = group;\n      \n      if (headerTokens.length > 0 && group.length > 0) {\n        const headerLine = group[0];\n        const headerParts = headerLine.split(',');\n        \n        for (let i = 0; i < headerTokens.length; i++) {\n          const token = headerTokens[i];\n          const rawPart = headerParts[i] || '';\n          const trimmedPart = rawPart.trim();\n          \n          headerRawValues[token.name] = rawPart || token.defaultValue;\n          headerTokenValues[token.name] = toPascalCase(trimmedPart || token.defaultValue);\n        }\n        \n        // Skip the header line for table processing\n        dataLines = group.slice(1);\n      }\n\n      // Process table data for this group\n      const groupTokenData: Array<Record<string, string>> = [];\n      const structuredFragments: { [fragmentName: string]: { header?: string; body: string[]; footer?: string } } = {};\n      const groupedFragments: { [fragmentName: string]: { [fragmentKey: string]: string[] } } = {};\n      \n      // If we have no data lines but have table tokens, that's an error\n      if (tableTokens.length > 0 && dataLines.length === 0) {\n        throw new Error(`Group ${groupIndex + 1}: No data lines found. Header tokens were processed but no table data rows remain.`);\n      }\n      \n      for (const line of dataLines) {\n        const rawParts = line.split(',');\n        \n        // Build token values for this line (combine header and table tokens)\n        const rawTokenValues: Record<string, string> = { ...headerRawValues };\n        const cleanTokenValues: Record<string, string> = { ...headerTokenValues };\n        \n        // Add table tokens\n        for (let i = 0; i < tableTokens.length; i++) {\n          const token = tableTokens[i];\n          const rawPart = rawParts[i] || '';\n          const trimmedPart = rawPart.trim();\n          \n          rawTokenValues[token.name] = rawPart || token.defaultValue;\n          cleanTokenValues[token.name] = toPascalCase(trimmedPart || token.defaultValue);\n        }\n        \n        // Store token data for the table\n        groupTokenData.push({ ...cleanTokenValues });\n\n        // Process each selected fragment definition\n        for (const fragmentDef of selectedFragmentDefs) {\n          const { processedFragments, warnings: fragmentWarnings } = processFragmentTemplates(\n            fragmentDef.fragments, \n            cleanTokenValues, \n            suppressWarnings\n          );\n          allWarnings.push(...fragmentWarnings);\n\n          const fragmentType = fragmentDef.type || 'grouped'; // Default to 'grouped'\n          \n          if (fragmentType === 'table') {\n            // Table type uses header/body/footer structure\n            if (!(fragmentDef.name in structuredFragments)) {\n              structuredFragments[fragmentDef.name] = { body: [] };\n            }\n            \n            // Process header (only once per group)\n            if (!structuredFragments[fragmentDef.name].header && processedFragments.header) {\n              const rendered = renderTemplate(processedFragments.header, cleanTokenValues, rawTokenValues, suppressWarnings);\n              structuredFragments[fragmentDef.name].header = rendered.result;\n              allWarnings.push(...rendered.warnings);\n            }\n            \n            // Process body (for each row) - handle both single body and nested fragments\n            if (processedFragments.body) {\n              const rendered = renderTemplate(processedFragments.body, cleanTokenValues, rawTokenValues, suppressWarnings);\n              structuredFragments[fragmentDef.name].body.push(rendered.result);\n              allWarnings.push(...rendered.warnings);\n            }\n            \n            // Process nested body fragments (like \"body - Attributes\", \"body - Labels\")\n            for (const [key, template] of Object.entries(processedFragments)) {\n              if (key.startsWith('body - ')) {\n                const rendered = renderTemplate(template, cleanTokenValues, rawTokenValues, suppressWarnings);\n                structuredFragments[fragmentDef.name].body.push(rendered.result);\n                allWarnings.push(...rendered.warnings);\n              }\n            }\n            \n            // Process footer (only once per group, but we'll set it each time - last one wins)\n            if (processedFragments.footer) {\n              const rendered = renderTemplate(processedFragments.footer, cleanTokenValues, rawTokenValues, suppressWarnings);\n              structuredFragments[fragmentDef.name].footer = rendered.result;\n              allWarnings.push(...rendered.warnings);\n            }\n          } else {\n            // Grouped type uses original fragment grouping behavior\n            if (!(fragmentDef.name in groupedFragments)) {\n              groupedFragments[fragmentDef.name] = {};\n            }\n            \n            // Process each fragment template and group by fragment key\n            for (const [key, template] of Object.entries(processedFragments)) {\n              const rendered = renderTemplate(template, cleanTokenValues, rawTokenValues, suppressWarnings);\n              allWarnings.push(...rendered.warnings);\n              \n              // Group fragments by key (e.g., \"attribute\", \"label\", etc.)\n              if (!groupedFragments[fragmentDef.name][key]) {\n                groupedFragments[fragmentDef.name][key] = [];\n              }\n              groupedFragments[fragmentDef.name][key].push(rendered.result);\n            }\n          }\n        }\n      }\n\n      // Create token table for this group\n      const allTokenNames = [...headerTokens.map(t => t.name), ...tableTokens.map(t => t.name)];\n      const tokenTable = createFormattedTokenTable(allTokenNames, groupTokenData, tokenDefaults, groupIndex + 1);\n      \n      // Build output for this group\n      const groupOutputSections: string[] = [tokenTable];\n      \n      // Add structured fragments (table type)\n      for (const [fragmentName, fragments] of Object.entries(structuredFragments)) {\n        const parts: string[] = [];\n        if (fragments.header) parts.push(fragments.header);\n        parts.push(...fragments.body);\n        if (fragments.footer) parts.push(fragments.footer);\n        \n        groupOutputSections.push(`\\n<!-- ${fragmentName} -->\\n\\n${parts.join('\\n')}`);\n      }\n      \n      // Add grouped fragments (grouped type)\n      for (const [fragmentName, fragmentGroups] of Object.entries(groupedFragments)) {\n        for (const [fragmentKey, fragments] of Object.entries(fragmentGroups)) {\n          //groupOutputSections.push(`\\n<!-- ${fragmentName} - ${fragmentKey} -->\\n\\n${fragments.join('\\n')}`);\n          groupOutputSections.push(`\\n<!-- ${fragmentKey} -->\\n\\n${fragments.join('\\n')}`);\n        }\n      }\n      \n      \n      outputSections.push(groupOutputSections.join('\\n\\n'));\n    }\n\n    // Show warnings if any and not suppressed\n    if (allWarnings.length > 0 && !suppressWarnings) {\n      vscode.window.showWarningMessage(`Kahua: ${allWarnings.join('; ')}`);\n    }\n\n    let generatedXml = outputSections.join('\\n\\n');\n    \n    // Apply XML formatting if enabled\n    const formatXmlOutput = config.get<boolean>('kahua.formatXmlOutput');\n    const xmlIndentSize = config.get<number>('kahua.xmlIndentSize') || 2;\n    \n    if (formatXmlOutput !== false) { // Default to true if not configured\n      generatedXml = formatXml(generatedXml, xmlIndentSize);\n    }\n      \n    // Get the output target setting\n    const outputTarget = config.get<string>('kahua.outputTarget') || 'newEditor';\n\n    if (outputTarget === 'newEditor') {\n      const newDocument = await vscode.workspace.openTextDocument({\n        content: generatedXml,\n        language: 'xml'\n      });\n\n      await vscode.window.showTextDocument(newDocument, {\n        viewColumn: vscode.ViewColumn.Beside,\n        preview: false\n      });\n\n      vscode.window.showInformationMessage(`Kahua: Generated fragments for ${fragmentIds.join(', ')} in new editor window`);\n    } else {\n      await vscode.env.clipboard.writeText(generatedXml);\n      vscode.window.showInformationMessage(`Kahua: Generated fragments for ${fragmentIds.join(', ')} copied to clipboard`);\n    }\n\n  } catch (error) {\n    const message = error instanceof Error ? error.message : 'Unknown error occurred';\n    vscode.window.showErrorMessage(`Kahua Attribute Generator: ${message}`);\n  }\n}\n\n\n"]}