{"version":3,"file":"extension.js","sourceRoot":"","sources":["../src/extension.ts"],"names":[],"mappings":";;AAMA,4BAaC;AAMD,gCAEC;AA3BD,iCAAiC;AAEjC;;;GAGG;AACH,SAAgB,QAAQ,CAAC,OAAgC;IACvD,4EAA4E;IAC5E,uDAAuD;IACvD,iFAAiF;IACjF,6GAA6G;IAC7G,mEAAmE;IACnE,0EAA0E;IAC1E,4EAA4E;IAC5E,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAAE,yBAAyB,EAAE,IAAI,CAAC,CAAC;IAC9E,OAAO,CAAC,aAAa,CAAC,IAAI,CACxB,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,iCAAiC,EAAE,GAAG,EAAE,CAAC,eAAe,CAAC,WAAW,CAAC,CAAC,EACtG,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,kCAAkC,EAAE,GAAG,EAAE,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CACzG,CAAC;AACJ,CAAC;AAED;;;GAGG;AACH,SAAgB,UAAU;IACxB,WAAW;AACb,CAAC;AAED;;;;;;;;;GASG;AACH,KAAK,UAAU,eAAe,CAAC,IAAgC;IAC7D,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC;IAC9C,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,OAAO;IACT,CAAC;IAED,mGAAmG;IACnG,MAAM,UAAU,GAAW,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC,GAAG,CAAS,uBAAuB,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;IAEhH,8EAA8E;IAC9E,MAAM,SAAS,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAC5D,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAE1E,qGAAqG;IACrG,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC;IAE/C,kHAAkH;IAClH,MAAM,eAAe,GAAG,CAAC,GAAG,EAAE;QAC5B,MAAM,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC,4CAA4C,CAAC,CAAC;QAC/E,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;IAC/B,CAAC,CAAC,EAAE,CAAC;IAEL,4EAA4E;IAC5E,MAAM,MAAM,GAAG,CAAC,GAAW,EAAE,QAAgB,EAAU,EAAE;QACvD,OAAO,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC,GAAG,CAAS,gBAAgB,GAAG,EAAE,CAAC,IAAI,QAAQ,CAAC;IAC5F,CAAC,CAAC;IAEF,6CAA6C;IAC7C,MAAM,gBAAgB,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC,GAAG,CAAS,kBAAkB,CAAC,IAAI,wBAAwB,CAAC;IACzH,MAAM,UAAU,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAElF,oDAAoD;IACpD,MAAM,iBAAiB,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC,GAAG,CAAyB,iBAAiB,CAAC,IAAI,EAAE,CAAC;IAEnH,MAAM,QAAQ,GAA6B,EAAE,CAAC;IAC9C,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,2BAA2B;QACnF,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,yBAAyB;QACpF,IAAI,CAAC,KAAK,CAAC,MAAM;YAAE,SAAS;QAE5B,iEAAiE;QACjE,MAAM,WAAW,GAA2B,EAAE,CAAC;QAE/C,+BAA+B;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,KAAK,GAAG,EAAE,CAAC;YAEf,IAAI,SAAS,KAAK,MAAM,EAAE,CAAC;gBACzB,oFAAoF;gBACpF,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAChE,CAAC;iBAAM,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;gBACjC,iDAAiD;gBACjD,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YACzB,CAAC;iBAAM,IAAI,SAAS,KAAK,QAAQ,EAAE,CAAC;gBAClC,sFAAsF;gBACtF,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,eAAe,IAAI,UAAU,CAAC;YACpD,CAAC;iBAAM,IAAI,SAAS,KAAK,MAAM,EAAE,CAAC;gBAChC,0BAA0B;gBAC1B,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC;YAC7B,CAAC;iBAAM,CAAC;gBACN,kEAAkE;gBAClE,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YACzB,CAAC;YAED,WAAW,CAAC,SAAS,CAAC,GAAG,KAAK,CAAC;QACjC,CAAC;QAED,2CAA2C;QAC3C,MAAM,cAAc,GAA2B,EAAE,CAAC;QAClD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAC3C,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,SAAS,KAAK,MAAM,IAAI,SAAS,KAAK,OAAO,EAAE,CAAC;gBAClD,uDAAuD;gBACvD,cAAc,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YAChD,CAAC;iBAAM,IAAI,SAAS,KAAK,QAAQ,EAAE,CAAC;gBAClC,yCAAyC;gBACzC,cAAc,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,eAAe,IAAI,UAAU,CAAC;YAC3E,CAAC;iBAAM,CAAC;gBACN,kCAAkC;gBAClC,cAAc,CAAC,SAAS,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YAChD,CAAC;QACH,CAAC;QAED,oDAAoD;QACpD,KAAK,MAAM,CAAC,GAAG,EAAE,QAAQ,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,EAAE,CAAC;YAChE,IAAI,QAAQ,GAAG,QAAQ,CAAC;YAExB,2EAA2E;YAC3E,KAAK,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE,CAAC;gBAClE,MAAM,QAAQ,GAAG,cAAc,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;gBAEjD,sEAAsE;gBACtE,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,SAAS,YAAY,EAAE,QAAQ,CAAC,CAAC;gBAEpE,qEAAqE;gBACrE,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,SAAS,YAAY,EAAE,UAAU,CAAC,CAAC;gBAEtE,oEAAoE;gBACpE,QAAQ,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,SAAS,GAAG,EAAE,UAAU,CAAC,CAAC;YAC/D,CAAC;YAED,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACxC,CAAC;IACH,CAAC;IAGD,4EAA4E;IAC5E,MAAM,YAAY,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;SAC1C,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAqB,EAAE,EAAE,CACxC,QAAQ,GAAG,SAAS,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CACvC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAEjB,gCAAgC;IAChC,MAAM,YAAY,GAAG,MAAM,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC,GAAG,CAAS,oBAAoB,CAAC,IAAI,WAAW,CAAC;IAE1G,IAAI,YAAY,KAAK,WAAW,EAAE,CAAC;QACjC,4BAA4B;QAC5B,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC;YAC1D,OAAO,EAAE,YAAY;YACrB,QAAQ,EAAE,KAAK;SAChB,CAAC,CAAC;QAEH,MAAM,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,WAAW,EAAE;YAChD,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC,MAAM;YACpC,OAAO,EAAE,KAAK;SACf,CAAC,CAAC;QAEH,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,oBAAoB,IAAI,kCAAkC,CAAC,CAAC;IACnG,CAAC;SAAM,CAAC;QACN,wCAAwC;QACxC,MAAM,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QACnD,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,oBAAoB,IAAI,iCAAiC,CAAC,CAAC;IAClG,CAAC;AACH,CAAC","sourcesContent":["import * as vscode from 'vscode';\n\n/**\n * This function is called when your extension is activated. Your extension is activated\n * the very first time the command is executed.\n */\nexport function activate(context: vscode.ExtensionContext) {\n  // Register commands for both extension and supplement modes. Each will call\n  // the shared handler with the appropriate mode string.\n  // This allows the extension to be used from the command palette or context menu.\n  // The commands are registered with the context so they can be disposed of when the extension is deactivated.\n  // The commands are also added to the context menu for easy access.\n  // The context variable 'kahua.showInContextMenu' is set to true to enable\n  // the context menu items when the editor has focus and a selection is made.\n  vscode.commands.executeCommand('setContext', 'kahua.showInContextMenu', true);\n  context.subscriptions.push(\n    vscode.commands.registerCommand('kahua.createExtensionAttributes', () => handleSelection('extension')),\n    vscode.commands.registerCommand('kahua.createSupplementAttributes', () => handleSelection('supplement')),\n  );\n}\n\n/**\n * This function is called when your extension is deactivated. Nothing to clean up\n * at the moment, but the function is required by VS Code's API.\n */\nexport function deactivate() {\n  /* noâ€‘op */\n}\n\n/**\n * Handles the logic of reading the current selection and generating XML snippets\n * based on the provided mode. When invoked, it reads each selected line,\n * sanitizes it to form a valid attribute name, and then creates attribute,\n * label, datatag, field and field definition fragments according to user\n * configurable templates. The result is placed on the clipboard and a\n * notification is shown.\n *\n * @param mode Determines which prefix configuration key to use: \"extension\" or \"supplement\".\n */\nasync function handleSelection(mode: 'extension' | 'supplement'): Promise<void> {\n  const editor = vscode.window.activeTextEditor;\n  if (!editor) {\n    return;\n  }\n\n  // Fetch the base prefix for the current mode from configuration. Defaults defined in package.json.\n  const modePrefix: string = vscode.workspace.getConfiguration().get<string>(`kahua.defaultPrefix.${mode}`) || '';\n\n  // Grab the currently selected text and split it into trimmed, nonempty lines.\n  const selection = editor.document.getText(editor.selection);\n  const lines = selection.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n\n  // Read the entire document to allow fallback prefix extraction from the first EntityDef when needed.\n  const documentText = editor.document.getText();\n\n  // Attempt to find the first <EntityDef Name=\"...\"> in the document. Used when only an attribute name is provided.\n  const firstEntityName = (() => {\n    const match = documentText.match(/<\\s*EntityDef[^>]*\\bName\\s*=\\s*\"([^\"<>]+)\"/);\n    return match ? match[1] : '';\n  })();\n\n  // Helper to fetch a template from configuration with fallback to a default.\n  const format = (key: string, fallback: string): string => {\n    return vscode.workspace.getConfiguration().get<string>(`kahua.tokens.${key}`) || fallback;\n  };\n\n  // Get configurable token names from settings\n  const tokenNamesConfig = vscode.workspace.getConfiguration().get<string>('kahua.tokenNames') || 'name,prefix,type,label';\n  const tokenNames = tokenNamesConfig.split(',').map(t => t.trim()).filter(Boolean);\n\n  // For each line produce a set of XML snippet parts.\n  const fragmentTemplates = vscode.workspace.getConfiguration().get<Record<string, string>>('kahua.fragments') || {};\n\n  const expanded: Record<string, string[]> = {};\n  for (const line of lines) {\n    const rawParts = line.split(',').filter(p => p !== ''); // Keep original whitespace\n    const parts = rawParts.map(p => p.trim()).filter(Boolean); // Trimmed for processing\n    if (!parts.length) continue;\n\n    // Build token values dynamically based on configured token names\n    const tokenValues: Record<string, string> = {};\n    \n    // Handle each configured token\n    for (let i = 0; i < tokenNames.length; i++) {\n      const tokenName = tokenNames[i];\n      let value = '';\n      \n      if (tokenName === 'name') {\n        // For 'name' token, store the sanitized version but we'll handle raw in replacement\n        value = parts[0] ? parts[0].replace(/[^A-Za-z0-9]/g, '') : '';\n      } else if (tokenName === 'label') {\n        // Label uses the original unsanitized first part\n        value = parts[0] || '';\n      } else if (tokenName === 'prefix') {\n        // Prefix logic: use provided value, fall back to document EntityDef, then mode prefix\n        value = parts[i] || firstEntityName || modePrefix;\n      } else if (tokenName === 'type') {\n        // Type defaults to 'Text'\n        value = parts[i] || 'Text';\n      } else {\n        // For any other token, use the corresponding part or empty string\n        value = parts[i] || '';\n      }\n      \n      tokenValues[tokenName] = value;\n    }\n    \n    // Store raw parts for friendly mode access\n    const rawTokenValues: Record<string, string> = {};\n    for (let i = 0; i < tokenNames.length; i++) {\n      const tokenName = tokenNames[i];\n      if (tokenName === 'name' || tokenName === 'label') {\n        // For name and label, preserve the original first part\n        rawTokenValues[tokenName] = rawParts[0] || '';\n      } else if (tokenName === 'prefix') {\n        // For prefix, use raw input or fallbacks\n        rawTokenValues[tokenName] = rawParts[i] || firstEntityName || modePrefix;\n      } else {\n        // For other tokens, use raw input\n        rawTokenValues[tokenName] = rawParts[i] || '';\n      }\n    }\n\n    // Apply token replacement for all configured tokens\n    for (const [key, template] of Object.entries(fragmentTemplates)) {\n      let rendered = template;\n      \n      // Handle both simple {token} and whitespace-controlled {token:mode} syntax\n      for (const [tokenName, tokenValue] of Object.entries(tokenValues)) {\n        const rawValue = rawTokenValues[tokenName] || '';\n        \n        // Replace {token:friendly} - preserves original whitespace/formatting\n        rendered = rendered.replaceAll(`{${tokenName}:friendly}`, rawValue);\n        \n        // Replace {token:internal} - uses processed/trimmed value (explicit)\n        rendered = rendered.replaceAll(`{${tokenName}:internal}`, tokenValue);\n        \n        // Replace {token} - default behavior (uses processed/trimmed value)\n        rendered = rendered.replaceAll(`{${tokenName}}`, tokenValue);\n      }\n      \n      (expanded[key] ??= []).push(rendered);\n    }\n  }\n\n\n  // Join each category of snippets together so they're grouped in the output.\n  const generatedXml = Object.entries(expanded)\n    .map(([key, lines]: [string, string[]]) =>\n      `<!-- ${key} -->\\n${lines.join('\\n')}`\n    ).join('\\n\\n');\n    \n  // Get the output target setting\n  const outputTarget = vscode.workspace.getConfiguration().get<string>('kahua.outputTarget') || 'clipboard';\n\n  if (outputTarget === 'newEditor') {\n    // Open in new editor window\n    const newDocument = await vscode.workspace.openTextDocument({\n      content: generatedXml,\n      language: 'xml'\n    });\n\n    await vscode.window.showTextDocument(newDocument, {\n      viewColumn: vscode.ViewColumn.Beside,\n      preview: false\n    });\n\n    vscode.window.showInformationMessage(`Kahua: Generated ${mode} attributes in new editor window`);\n  } else {\n    // Copy to clipboard (existing behavior)\n    await vscode.env.clipboard.writeText(generatedXml);\n    vscode.window.showInformationMessage(`Kahua: Generated ${mode} attributes copied to clipboard`);\n  }\n}"]}